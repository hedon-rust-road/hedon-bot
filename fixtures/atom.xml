<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Go Blog</title>
  <id>tag:blog.golang.org,2013:blog.golang.org</id>
  <link rel="self" href="https://go.dev/blog/feed.atom"/>
  <updated>2024-05-02T00:00:00+00:00</updated>
  <entry>
    <title>Secure Randomness in Go 1.22</title>
    <id>tag:blog.golang.org,2013:blog.golang.org/chacha8rand</id>
    <link rel="alternate" href="https://go.dev/blog/chacha8rand"/>
    <published>2024-05-02T00:00:00+00:00</published>
    <updated>2024-05-02T00:00:00+00:00</updated>
    <author>
      <name/>
    </author>
    <summary type="html">ChaCha8Rand is a new cryptographically secure pseudorandom number generator used in Go 1.22.</summary>
    <content type="html">&lt;div id="blog"&gt;&lt;div id="content"&gt; &lt;div id="content"&gt; &lt;div class="Article" data-slug="/blog/chacha8rand"&gt; &lt;h1 class="small"&gt;&lt;a href="/blog/"&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt; &lt;h1&gt;Secure Randomness in Go 1.22&lt;/h1&gt; &lt;p class="author"&gt; Russ Cox and Filippo Valsorda&lt;br&gt; 2 May 2024 &lt;/p&gt; &lt;p&gt;Computers aren&amp;rsquo;t random. On the contrary, hardware designers work very hard to make sure computers run every program the same way every time. So when a program does need random numbers, that requires extra effort. Traditionally, computer scientists and programming languages have distinguished between two different kinds of random numbers: statistical and cryptographic randomness. In Go, those are provided by &lt;a href="/pkg/math/rand/"&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; and &lt;a href="/pkg/crypto/rand"&gt;&lt;code&gt;crypto/rand&lt;/code&gt;&lt;/a&gt;, respectively. This post is about how Go 1.22 brings the two closer together, by using a cryptographic random number source in &lt;code&gt;math/rand&lt;/code&gt; (as well as &lt;code&gt;math/rand/v2&lt;/code&gt;, as mentioned in our &lt;a href="/blog/randv2"&gt;previous post&lt;/a&gt;). The result is better randomness and far less damage when developers accidentally use &lt;code&gt;math/rand&lt;/code&gt; instead of &lt;code&gt;crypto/rand&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Before we can explain what Go 1.22 did, let&amp;rsquo;s take a closer look at statistical randomness compared to cryptographic randomness.&lt;/p&gt; &lt;h2 id="statistical-randomness"&gt;Statistical Randomness&lt;/h2&gt; &lt;p&gt;Random numbers that pass basic statistical tests are usually appropriate for use cases like simulations, sampling, numerical analysis, non-cryptographic randomized algorithms, &lt;a href="/doc/security/fuzz/"&gt;random testing&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noreferrer" target="_blank"&gt;shuffling inputs&lt;/a&gt;, and &lt;a href="https://en.wikipedia.org/wiki/Exponential_backoff#Collision_avoidance" rel="noreferrer" target="_blank"&gt;random exponential backoff&lt;/a&gt;. Very basic, easy to compute mathematical formulas turn out to work well enough for these use cases. Because the methods are so simple, however, an observer who knows what algorithm is being used can typically predict the rest of the sequence after seeing enough values.&lt;/p&gt; &lt;p&gt;Essentially all programming environments provide a mechanism for generating statistical random numbers that traces back through C to Research Unix Third Edition (V3), which added a pair of functions: &lt;code&gt;srand&lt;/code&gt; and &lt;code&gt;rand&lt;/code&gt;. The manual page included a note that read:&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;&lt;em&gt;WARNING The author of this routine has been writing random-number generators for many years and has never been known to write one that worked.&lt;/em&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;This note was partly a joke but also an acknowledgement that such generators are &lt;a href="https://www.tuhs.org/pipermail/tuhs/2024-March/029587.html" rel="noreferrer" target="_blank"&gt;inherently not random&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;The source code of the generator makes clear how trivial it is. Translated from PDP-11 assembly to modern C, it was:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;uint16 ranx; void srand(uint16 seed) { ranx = seed; } int16 rand(void) { ranx = 13077*ranx + 6925; return ranx &amp;amp; ~0x8000; } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Calling &lt;code&gt;srand&lt;/code&gt; seeds the generator with a single integer seed, and &lt;code&gt;rand&lt;/code&gt; returns the next number from the generator. The AND in the return statement clears the sign bit to make sure the result is positive.&lt;/p&gt; &lt;p&gt;This function is an instance of the general class of &lt;a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="noreferrer" target="_blank"&gt;linear congruential generators (LCGs)&lt;/a&gt;, which Knuth analyzes in &lt;em&gt;The Art of Computer Programming&lt;/em&gt;, Volume 2, section 3.2.1. The main benefit of LCGs is that constants can be chosen such that they emit every possible output value once before repeating, as the Unix implementation did for 15-bit outputs. A serious problem with LCGs, however, is that the high bits of the state do not affect the low bits at all, so every truncation of the sequence to &lt;em&gt;k&lt;/em&gt; bits necessarily repeats with a smaller period. The low bit must toggle: 0, 1, 0, 1, 0, 1. The low two bits must count up or down: 0, 1, 2, 3, 0, 1, 2, 3, or else 0, 3, 2, 1, 0, 3, 2, 1. There are four possible three-bit sequences; the original Unix implementation repeats 0, 5, 6, 3, 4, 1, 2, 7. (These problems can be avoided by reducing the value modulo a prime, but that would have been quite expensive at the time. See S. K. Park and K. W. Miller&amp;rsquo;s 1988 CACM paper “&lt;a href="https://dl.acm.org/doi/10.1145/63039.63042" rel="noreferrer" target="_blank"&gt;Random number generators: good ones are hard to find&lt;/a&gt;” for a short analysis and the first chapter of Knuth Volume 2 for a longer one.)&lt;/p&gt; &lt;p&gt;Even with these known problems, the &lt;code&gt;srand&lt;/code&gt; and &lt;code&gt;rand&lt;/code&gt; functions were included in the first C standard, and equivalent functionality was included in essentially every language since then. LCGs were once the dominant implementation strategy, although they&amp;rsquo;ve fallen off in popularity due to some important drawbacks. One significant remaining use is &lt;a href="https://github.com/openjdk/jdk8u-dev/blob/master/jdk/src/share/classes/java/util/Random.java" rel="noreferrer" target="_blank"&gt;&lt;code&gt;java.util.Random&lt;/code&gt;&lt;/a&gt;, which powers &lt;a href="https://github.com/openjdk/jdk8u-dev/blob/master/jdk/src/share/classes/java/util/Random.java" rel="noreferrer" target="_blank"&gt;&lt;code&gt;java.lang.Math.random&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Another thing you can see from the implementation above is that the internal state is completely exposed by the result of &lt;code&gt;rand&lt;/code&gt;. An observer who knows the algorithm and sees a single result can easily compute all future results. If you are running a server that calculates some random values that become public and some random values that must stay secret, using this kind of generator would be disastrous: the secrets wouldn&amp;rsquo;t be secret.&lt;/p&gt; &lt;p&gt;More modern random generators aren&amp;rsquo;t as terrible as the original Unix one, but they&amp;rsquo;re still not completely unpredictable. To make that point, next we will look at the original &lt;code&gt;math/rand&lt;/code&gt; generator from Go 1 and the PCG generator we added in &lt;code&gt;math/rand/v2&lt;/code&gt;.&lt;/p&gt; &lt;h2 id="the-go-1-generator"&gt;The Go 1 Generator&lt;/h2&gt; &lt;p&gt;The generator used in Go 1&amp;rsquo;s &lt;code&gt;math/rand&lt;/code&gt; is an instance of what is called a &lt;a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" rel="noreferrer" target="_blank"&gt;linear-feedback shift register&lt;/a&gt;. The algorithm is based on an idea by George Marsaglia, tweaked by Don Mitchell and Jim Reeds, and further customized by Ken Thompson for Plan 9 and then Go. It has no official name, so this post calls it the Go 1 generator.&lt;/p&gt; &lt;p&gt;The Go 1 generator&amp;rsquo;s internal state is a slice &lt;code&gt;vec&lt;/code&gt; of 607 uint64s. In that slice, there are two distinguished elements: &lt;code&gt;vec[606]&lt;/code&gt;, the last element, is called the “tap”, and &lt;code&gt;vec[334]&lt;/code&gt; is called the “feed”. To generate the next random number, the generator adds the tap and the feed to produce a value &lt;code&gt;x&lt;/code&gt;, stores &lt;code&gt;x&lt;/code&gt; back into the feed, shifts the entire slice one position to the right (the tap moves to &lt;code&gt;vec[0]&lt;/code&gt; and &lt;code&gt;vec[i]&lt;/code&gt; moves to &lt;code&gt;vec[i+1]&lt;/code&gt;), and returns &lt;code&gt;x&lt;/code&gt;. The generator is called “linear feedback” because the tap is &lt;em&gt;added&lt;/em&gt; to the feed; the entire state is a “shift register” because each step shifts the slice entries.&lt;/p&gt; &lt;p&gt;Of course, actually moving every slice entry forward would be prohibitively expensive, so instead the implementation leaves the slice data in place and moves the tap and feed positions backward on each step. The code looks like:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;func (r *rngSource) Uint64() uint64 { r.tap-- if r.tap &amp;lt; 0 { r.tap += len(r.vec) } r.feed-- if r.feed &amp;lt; 0 { r.feed += len(r.vec) } x := r.vec[r.feed] + r.vec[r.tap] r.vec[r.feed] = x return uint64(x) } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Generating the next number is quite cheap: two subtractions, two conditional adds, two loads, one add, one store.&lt;/p&gt; &lt;p&gt;Unfortunately, because the generator directly returns one slice element from its internal state vector, reading 607 values from the generator completely exposes all its state. With those values, you can predict all the future values, by filling in your own &lt;code&gt;vec&lt;/code&gt; and then running the algorithm. You can also recover all the previous values, by running the algorithm backward (subtracting the tap from the feed and shifting the slice to the left).&lt;/p&gt; &lt;p&gt;As a complete demonstration, here is an &lt;a href="/play/p/v0QdGjUAtzC"&gt;insecure program&lt;/a&gt; generating pseudorandom authentication tokens along with code that predicts the next token given a sequence of earlier tokens. As you can see, the Go 1 generator provides no security at all (nor was it meant to). The quality of the generated numbers also depends on the initial setting of &lt;code&gt;vec&lt;/code&gt;.&lt;/p&gt; &lt;h2 id="the-pcg-generator"&gt;The PCG Generator&lt;/h2&gt; &lt;p&gt;For &lt;code&gt;math/rand/v2&lt;/code&gt;, we wanted to provide a more modern statistical random generator and settled on Melissa O&amp;rsquo;Neill&amp;rsquo;s PCG algorithm, published in 2014 in her paper “&lt;a href="https://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf" rel="noreferrer" target="_blank"&gt;PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation&lt;/a&gt;”. The exhaustive analysis in the paper can make it hard to notice at first glance how utterly trivial the generators are: PCG is a post-processed 128-bit LCG.&lt;/p&gt; &lt;p&gt;If the state &lt;code&gt;p.x&lt;/code&gt; were a &lt;code&gt;uint128&lt;/code&gt; (hypothetically), the code to compute the next value would be:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;const ( pcgM = 0x2360ed051fc65da44385df649fccf645 pcgA = 0x5851f42d4c957f2d14057b7ef767814f ) type PCG struct { x uint128 } func (p *PCG) Uint64() uint64 { p.x = p.x * pcgM + pcgA return scramble(p.x) } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The entire state is a single 128-bit number, and the update is a 128-bit multiply and add. In the return statement, the &lt;code&gt;scramble&lt;/code&gt; function reduces the 128-bit state down to a 64-bit state. The original PCG used (again using a hypothetical &lt;code&gt;uint128&lt;/code&gt; type):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;func scramble(x uint128) uint64 { return bits.RotateLeft(uint64(x&amp;gt;&amp;gt;64) ^ uint64(x), -int(x&amp;gt;&amp;gt;122)) } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This code XORs the two halves of the 128-bit state together and then rotates the result according to the top six bits of the state. This version is called PCG-XSL-RR, for “xor shift low, right rotate”.&lt;/p&gt; &lt;p&gt;Based on a &lt;a href="/issue/21835#issuecomment-739065688"&gt;suggestion from O&amp;rsquo;Neill during proposal discussion&lt;/a&gt;, Go&amp;rsquo;s PCG uses a new scramble function based on multiplication, which mixes the bits more aggressively:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;func scramble(x uint128) uint64 { hi, lo := uint64(x&amp;gt;&amp;gt;64), uint64(x) hi ^= hi &amp;gt;&amp;gt; 32 hi *= 0xda942042e4dd58b5 hi ^= hi &amp;gt;&amp;gt; 48 hi *= lo | 1 } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;O&amp;rsquo;Neill calls PCG with this scrambler PCG-DXSM, for “double xorshift multiply.” Numpy uses this form of PCG as well.&lt;/p&gt; &lt;p&gt;Although PCG uses more computation to generate each value, it uses significantly less state: two uint64s instead of 607. It is also much less sensitive to the initial values of that state, and &lt;a href="https://www.pcg-random.org/statistical-tests.html" rel="noreferrer" target="_blank"&gt;it passes many statistical tests that other generators do not&lt;/a&gt;. In many ways it is an ideal statistical generator.&lt;/p&gt; &lt;p&gt;Even so, PCG is not unpredictable. While the scrambling of bits to prepare the result does not expose the state directly like in the LCG and Go 1 generators, &lt;a href="https://pdfs.semanticscholar.org/4c5e/4a263d92787850edd011d38521966751a179.pdf" rel="noreferrer" target="_blank"&gt;PCG-XSL-RR can still be be reversed&lt;/a&gt;, and it would not be surprising if PCG-DXSM could too. For secrets, we need something different.&lt;/p&gt; &lt;h2 id="cryptographic-randomness"&gt;Cryptographic Randomness&lt;/h2&gt; &lt;p&gt;&lt;em&gt;Cryptographic random numbers&lt;/em&gt; need to be utterly unpredictable in practice, even to an observer who knows how they are generated and has observed any number of previously generated values. The safety of cryptographic protocols, secret keys, modern commerce, online privacy, and more all critically depend on access to cryptographic randomness.&lt;/p&gt; &lt;p&gt;Providing cryptographic randomness is ultimately the job of the operating system, which can gather true randomness from physical devices—timings of the mouse, keyboard, disks, and network, and more recently &lt;a href="https://web.archive.org/web/20141230024150/http://www.cryptography.com/public/pdf/Intel_TRNG_Report_20120312.pdf" rel="noreferrer" target="_blank"&gt;electrical noise measured directly by the CPU itself&lt;/a&gt;. Once the operating system has gathered a meaningful amount of randomness—say, at least 256 bits—it can use cryptographic hashing or encryption algorithms to stretch that seed into an arbitrarily long sequence of random numbers. (In practice the operating system is also constantly gathering and adding new randomness to the sequence too.)&lt;/p&gt; &lt;p&gt;The exact operating system interfaces have evolved over time. A decade ago, most systems provided a device file named &lt;code&gt;/dev/random&lt;/code&gt; or something similar. Today, in recognition of how fundamental randomness has become, operating systems provide a direct system call instead. (This also allows programs to read randomness even when cut off from the file system.) In Go, the &lt;a href="/pkg/crypto/rand/"&gt;&lt;code&gt;crypto/rand&lt;/code&gt;&lt;/a&gt; package abstracts away those details, providing the same interface on every operating system: &lt;a href="/pkg/crypto/rand/#Read"&gt;&lt;code&gt;rand.Read&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;It would not be practical for &lt;code&gt;math/rand&lt;/code&gt; to ask the operating system for randomness each time it needs a &lt;code&gt;uint64&lt;/code&gt;. But we can use cryptographic techniques to define an in-process random generator that improves on LCGs, the Go 1 generator, and even PCG.&lt;/p&gt; &lt;h2 id="the-chacha8rand-generator"&gt;The ChaCha8Rand Generator&lt;/h2&gt; &lt;p&gt;Our new generator, which we unimaginatively named ChaCha8Rand for specification purposes and implemented as &lt;code&gt;math/rand/v2&lt;/code&gt;&amp;rsquo;s &lt;a href="/pkg/math/rand/v2/#ChaCha8"&gt;&lt;code&gt;rand.ChaCha8&lt;/code&gt;&lt;/a&gt;, is a lightly modified version of Daniel J. Bernstein&amp;rsquo;s &lt;a href="https://cr.yp.to/chacha.html" rel="noreferrer" target="_blank"&gt;ChaCha stream cipher&lt;/a&gt;. ChaCha is widely used in a 20-round form called ChaCha20, including in TLS and SSH. Jean-Philippe Aumasson&amp;rsquo;s paper “&lt;a href="https://eprint.iacr.org/2019/1492.pdf" rel="noreferrer" target="_blank"&gt;Too Much Crypto&lt;/a&gt;” argues persuasively that the 8-round form ChaCha8 is secure too (and it&amp;rsquo;s roughly 2.5X faster). We used ChaCha8 as the core of ChaCha8Rand.&lt;/p&gt; &lt;p&gt;Most stream ciphers, including ChaCha8, work by defining a function that is given a key and a block number and produces a fixed-size block of apparently random data. The cryptographic standard these aim for (and usually meet) is for this output to be indistinguishable from actual random data in the absence of some kind of exponentially costly brute force search. A message is encrypted or decrypted by XOR&amp;rsquo;ing successive blocks of input data with successive randomly generated blocks. To use ChaCha8 as a &lt;code&gt;rand.Source&lt;/code&gt;, we use the generated blocks directly instead of XOR&amp;rsquo;ing them with input data (this is equivalent to encrypting or decrypting all zeros).&lt;/p&gt; &lt;p&gt;We changed a few details to make ChaCha8Rand more suitable for generating random numbers. Briefly:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;ChaCha8Rand takes a 32-byte seed, used as the ChaCha8 key.&lt;/li&gt; &lt;li&gt;ChaCha8 generates 64-byte blocks, with calculations treating a block as 16 &lt;code&gt;uint32&lt;/code&gt;s. A common implementation is to compute four blocks at a time using &lt;a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data" rel="noreferrer" target="_blank"&gt;SIMD instructions&lt;/a&gt; on 16 vector registers of four &lt;code&gt;uint32&lt;/code&gt;s each. This produces four interleaved blocks that must be unshuffled for XOR&amp;rsquo;ing with the input data. ChaCha8Rand defines that the interleaved blocks are the random data stream, removing the cost of the unshuffle. (For security purposes, this can be viewed as standard ChaCha8 followed by a reshuffle.)&lt;/li&gt; &lt;li&gt;ChaCha8 finishes a block by adding certain values to each &lt;code&gt;uint32&lt;/code&gt; in the block. Half the values are key material and the other half are known constants. ChaCha8Rand defines that the known constants are not re-added, removing half of the final adds. (For security purposes, this can be viewed as standard ChaCha8 followed by subtracting the known constants.)&lt;/li&gt; &lt;li&gt;Every 16th generated block, ChaCha8Rand takes the final 32 bytes of the block for itself, making them the key for the next 16 blocks. This provides a kind of &lt;a href="https://en.wikipedia.org/wiki/Forward_secrecy" rel="noreferrer" target="_blank"&gt;forward secrecy&lt;/a&gt;: if a system is compromised by an attack that recovers the entire memory state of the generator, only values generated since the last rekeying can be recovered. The past is inaccessible. ChaCha8Rand as defined so far must generate 4 blocks at a time, but we chose to do this key rotation every 16 blocks to leave open the possibility of faster implementations using 256-bit or 512-bit vectors, which could generate 8 or 16 blocks at a time.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;We wrote and published a &lt;a href="https://c2sp.org/chacha8rand" rel="noreferrer" target="_blank"&gt;C2SP specification for ChaCha8Rand&lt;/a&gt;, along with test cases. This will enable other implementations to share repeatability with the Go implementation for a given seed.&lt;/p&gt; &lt;p&gt;The Go runtime now maintains a per-core ChaCha8Rand state (300 bytes), seeded with operating system-supplied cryptographic randomness, so that random numbers can be generated quickly without any lock contention. Dedicating 300 bytes per core may sound expensive, but on a 16-core system, it is about the same as storing a single shared Go 1 generator state (4,872 bytes). The speed is worth the memory. This per-core ChaCha8Rand generator is now used in three different places in the Go standard library:&lt;/p&gt; &lt;ol&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;math/rand/v2&lt;/code&gt; package functions, such as &lt;a href="/pkg/math/rand/v2/#Float64"&gt;&lt;code&gt;rand.Float64&lt;/code&gt;&lt;/a&gt; and &lt;a href="/pkg/math/rand/v2/#N"&gt;&lt;code&gt;rand.N&lt;/code&gt;&lt;/a&gt;, always use ChaCha8Rand.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;math/rand&lt;/code&gt; package functions, such as &lt;a href="/pkg/math/rand/#Float64"&gt;&lt;code&gt;rand.Float64&lt;/code&gt;&lt;/a&gt; and &lt;a href="/pkg/math/rand/#Intn"&gt;&lt;code&gt;rand.Intn&lt;/code&gt;&lt;/a&gt;, use ChaCha8Rand when &lt;a href="/pkg/math/rand/#Seed"&gt;&lt;code&gt;rand.Seed&lt;/code&gt;&lt;/a&gt; has not been called. Applying ChaCha8Rand in &lt;code&gt;math/rand&lt;/code&gt; improves the security of programs even before they update to &lt;code&gt;math/rand/v2&lt;/code&gt;, provided they are not calling &lt;code&gt;rand.Seed&lt;/code&gt;. (If &lt;code&gt;rand.Seed&lt;/code&gt; is called, the implementation is required to fall back to the Go 1 generator for compatibility.)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The runtime chooses the hash seed for each new map using ChaCha8Rand instead of a less secure &lt;a href="https://github.com/wangyi-fudan/wyhash" rel="noreferrer" target="_blank"&gt;wyrand-based generator&lt;/a&gt; it previously used. Random seeds are needed because if an attacker knows the specific hash function used by a map implementation, they can prepare input that drives the map into quadratic behavior (see Crosby and Wallach&amp;rsquo;s “&lt;a href="https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks" rel="noreferrer" target="_blank"&gt;Denial of Service via Algorithmic Complexity Attacks&lt;/a&gt;”). Using a per-map seed, instead of one global seed for all maps, also avoids &lt;a href="https://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion" rel="noreferrer" target="_blank"&gt;other degenerate behaviors&lt;/a&gt;. It is not strictly clear that maps need a cryptographically random seed, but it&amp;rsquo;s also not clear that they don&amp;rsquo;t. It seemed prudent and was trivial to switch.&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Code that needs its own ChaCha8Rand instances can create its own &lt;a href="/pkg/math/rand/v2/#ChaCha8"&gt;&lt;code&gt;rand.ChaCha8&lt;/code&gt;&lt;/a&gt; directly.&lt;/p&gt; &lt;h2 id="fixing-security-mistakes"&gt;Fixing Security Mistakes&lt;/h2&gt; &lt;p&gt;Go aims to help developers write code that is secure by default. When we observe a common mistake with security consequences, we look for ways to reduce the risk of that mistake or eliminate it entirely. In this case, &lt;code&gt;math/rand&lt;/code&gt;&amp;rsquo;s global generator was far too predictable, leading to serious problems in a variety of contexts.&lt;/p&gt; &lt;p&gt;For example, when Go 1.20 deprecated &lt;a href="/pkg/math/rand/#Read"&gt;&lt;code&gt;math/rand&lt;/code&gt;’s &lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, we heard from developers who discovered (thanks to tooling pointing out use of deprecated functionality) they had been using it in places where &lt;a href="/pkg/crypto/rand/#Read"&gt;&lt;code&gt;crypto/rand&lt;/code&gt;’s &lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; was definitely needed, like generating key material. Using Go 1.20, that mistake is a serious security problem that merits a detailed investigation to understand the damage. Where were the keys used? How were the keys exposed? Were other random outputs exposed that might allow an attacker to derive the keys? And so on. Using Go 1.22, that mistake is just a mistake. It&amp;rsquo;s still better to use &lt;code&gt;crypto/rand&lt;/code&gt;, because the operating system kernel can do a better job keeping the random values secret from various kinds of prying eyes, the kernel is continually adding new entropy to its generator, and the kernel has had more scrutiny. But accidentally using &lt;code&gt;math/rand&lt;/code&gt; is no longer a security catastrophe.&lt;/p&gt; &lt;p&gt;There are also a variety of use cases that don&amp;rsquo;t seem like “crypto” but nonetheless need unpredictable randomness. These cases are made more robust by using ChaCha8Rand instead of the Go 1 generator.&lt;/p&gt; &lt;p&gt;For example, consider generating a &lt;a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)" rel="noreferrer" target="_blank"&gt;random UUID&lt;/a&gt;. Since UUIDs are not secret, using &lt;code&gt;math/rand&lt;/code&gt; might seem fine. But if &lt;code&gt;math/rand&lt;/code&gt; has been seeded with the current time, then running it at the same instant on different computers will produce the same value, making them not “universally unique”. This is especially likely on systems where the current time is only available with millisecond precision. Even with auto-seeding using OS-provided entropy, as introduced in Go 1.20, the Go 1 generator&amp;rsquo;s seed is only a 63-bit integer, so a program that generates a UUID at startup can only generate 2⁶³ possible UUIDs and is likely to see collisions after 2³¹ or so UUIDs. Using Go 1.22, the new ChaCha8Rand generator is seeded from 256 bits of entropy and can generate 2²⁵⁶ possible first UUIDs. It does not need to worry about collisions.&lt;/p&gt; &lt;p&gt;As another example, consider load balancing in a front-end server that randomly assigns incoming requests to back-end servers. If an attacker can observe the assignments and knows the predictable algorithm generating them, then the attacker could send a stream of mostly cheap requests but arrange for all the expensive requests to land on a single back-end server. This is an unlikely but plausible problem using the Go 1 generator. Using Go 1.22, it&amp;rsquo;s not a problem at all.&lt;/p&gt; &lt;p&gt;In all these examples, Go 1.22 has eliminated or greatly reduced security problems.&lt;/p&gt; &lt;h2 id="performance"&gt;Performance&lt;/h2&gt; &lt;p&gt;The security benefits of ChaCha8Rand do have a small cost, but ChaCha8Rand is still in the same ballpark as both the Go 1 generator and PCG. The following graphs compare the performance of the three generators, across a variety of hardware, running two operations: the primitive operation “Uint64,” which returns the next &lt;code&gt;uint64&lt;/code&gt; in the random stream, and the higher-level operation “N(1000),” which returns a random value in the range [0, 1000).&lt;/p&gt; &lt;div style="background-color: white;"&gt; &lt;img src="chacha8rand/amd.svg"&gt; &lt;img src="chacha8rand/intel.svg"&gt; &lt;img src="chacha8rand/amd32.svg"&gt; &lt;img src="chacha8rand/intel32.svg"&gt; &lt;img src="chacha8rand/m1.svg"&gt; &lt;img src="chacha8rand/m3.svg"&gt; &lt;img src="chacha8rand/taut2a.svg"&gt; &lt;/div&gt; &lt;p&gt;The “running 32-bit code” graphs show modern 64-bit x86 chips executing code built with &lt;code&gt;GOARCH=386&lt;/code&gt;, meaning they are running in 32-bit mode. In that case, the fact that PCG requires 128-bit multiplications makes it slower than ChaCha8Rand, which only uses 32-bit SIMD arithmetic. Actual 32-bit systems matter less every year, but it is still interesting that ChaCha8Rand is faster than PCG on those systems.&lt;/p&gt; &lt;p&gt;On some systems, “Go 1: Uint64” is faster than “PCG: Uint64”, but “Go 1: N(1000)” is slower than “PCG: N(1000)”. This happens because “Go 1: N(1000)” is using &lt;code&gt;math/rand&lt;/code&gt;&amp;rsquo;s algorithm for reducing a random &lt;code&gt;int64&lt;/code&gt; down to a value in the range [0, 1000), and that algorithm does two 64-bit integer divide operations. In contrast, “PCG: N(1000)” and “ChaCha8: N(1000)” use the &lt;a href="/blog/randv2#problem.rand"&gt;faster &lt;code&gt;math/rand/v2&lt;/code&gt; algorithm&lt;/a&gt;, which almost always avoids the divisions. Removing the 64-bit divisions dominates the algorithm change for 32-bit execution and on the Ampere.&lt;/p&gt; &lt;p&gt;Overall, ChaCha8Rand is slower than the Go 1 generator, but it is never more than twice as slow, and on typical servers the difference is never more than 3ns. Very few programs will be bottlenecked by this difference, and many programs will enjoy the improved security.&lt;/p&gt; &lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt; &lt;p&gt;Go 1.22 makes your programs more secure without any code changes. We did this by identifying the common mistake of accidentally using &lt;code&gt;math/rand&lt;/code&gt; instead of &lt;code&gt;crypto/rand&lt;/code&gt; and then strengthening &lt;code&gt;math/rand&lt;/code&gt;. This is one small step in Go&amp;rsquo;s ongoing journey to keep programs safe by default.&lt;/p&gt; &lt;p&gt;These kinds of mistakes are not unique to Go. For example, the npm &lt;code&gt;keypair&lt;/code&gt; package tries to generate an RSA key pair using Web Crypto APIs, but if they&amp;rsquo;re not available, it falls back to JavaScript&amp;rsquo;s &lt;code&gt;Math.random&lt;/code&gt;. This is hardly an isolated case, and the security of our systems cannot depend on developers not making mistakes. Instead, we hope that eventually all programming languages will move to cryptographically strong pseudorandom generators even for “mathematical” randomness, eliminating this kind of mistake, or at least greatly reducing its blast radius. Go 1.22&amp;rsquo;s &lt;a href="https://c2sp.org/chacha8rand" rel="noreferrer" target="_blank"&gt;ChaCha8Rand&lt;/a&gt; implementation proves that this approach is competitive with other generators.&lt;/p&gt; &lt;/div&gt; &lt;div class="Article prevnext"&gt; &lt;p&gt; &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href="/blog/randv2"&gt;Evolving the Go Standard Library with math/rand/v2&lt;/a&gt;&lt;br&gt; &lt;b&gt;&lt;a href="/blog/all"&gt;Blog Index&lt;/a&gt;&lt;/b&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/js/jquery.js"&gt;&lt;/script&gt; &lt;script src="/js/playground.js"&gt;&lt;/script&gt; &lt;script src="/js/play.js"&gt;&lt;/script&gt; &lt;script src="/js/godocs.js"&gt;&lt;/script&gt;</content>
  </entry>
  <entry>
    <title>Evolving the Go Standard Library with math/rand/v2</title>
    <id>tag:blog.golang.org,2013:blog.golang.org/randv2</id>
    <link rel="alternate" href="https://go.dev/blog/randv2"/>
    <published>2024-05-01T00:00:00+00:00</published>
    <updated>2024-05-01T00:00:00+00:00</updated>
    <author>
      <name/>
    </author>
    <summary type="html">Go 1.22 adds math/rand/v2 and charts a course for the evolution of the Go standard library.</summary>
    <content type="html">&lt;div id="blog"&gt;&lt;div id="content"&gt; &lt;div id="content"&gt; &lt;div class="Article" data-slug="/blog/randv2"&gt; &lt;h1 class="small"&gt;&lt;a href="/blog/"&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt; &lt;h1&gt;Evolving the Go Standard Library with math/rand/v2&lt;/h1&gt; &lt;p class="author"&gt; Russ Cox&lt;br&gt; 1 May 2024 &lt;/p&gt; &lt;p&gt;Since Go 1 was &lt;a href="/blog/go1"&gt;released in March 2012&lt;/a&gt;, changes to the standard library have been constrained by Go&amp;rsquo;s &lt;a href="/doc/go1compat"&gt;compatibility promise&lt;/a&gt;. Overall, compatibility has been a boon for Go users, providing a stable base for production systems, documentation, tutorials, books, and more. Over time, however, we&amp;rsquo;ve realized mistakes in the original APIs that cannot be fixed compatibly; in other cases, best practices and convention have changed. We need a plan for making important, breaking changes too.&lt;/p&gt; &lt;p&gt;This blog post is about Go 1.22&amp;rsquo;s new &lt;a href="/pkg/math/rand/v2/"&gt;&lt;code&gt;math/rand/v2&lt;/code&gt;&lt;/a&gt; package, the first “v2” in the standard library. It brings needed improvements to the &lt;a href="/pkg/math/rand/"&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; API, but more importantly it sets an example for how we can revise other standard library packages as the need arises.&lt;/p&gt; &lt;p&gt;(In Go, &lt;code&gt;math/rand&lt;/code&gt; and &lt;code&gt;math/rand/v2&lt;/code&gt; are two different packages with different import paths. Go 1 and every release after it have included &lt;code&gt;math/rand&lt;/code&gt;; Go 1.22 added &lt;code&gt;math/rand/v2&lt;/code&gt;. A Go program can import either package, or both.)&lt;/p&gt; &lt;p&gt;This post discusses the specific rationale for the changes in &lt;code&gt;math/rand/v2&lt;/code&gt; and then &lt;a href="#principles"&gt;reflects on the general principles&lt;/a&gt; that will guide new versions of other packages.&lt;/p&gt; &lt;h2 id="pseudo"&gt;Pseudorandom Number Generators&lt;/h2&gt; &lt;p&gt;Before we look at &lt;code&gt;math/rand&lt;/code&gt;, which is an API for a pseudorandom number generator, let&amp;rsquo;s take a moment to understand what that means.&lt;/p&gt; &lt;p&gt;A pseudorandom number generator is a deterministic program that generates a long sequence of seemingly random numbers from a small seed input, although the numbers are not in fact random at all. In the case of &lt;code&gt;math/rand&lt;/code&gt;, the seed is a single int64, and the algorithm produces a sequence of int64s using a variant of a &lt;a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" rel="noreferrer" target="_blank"&gt;linear-feedback shift register (LFSR)&lt;/a&gt;. The algorithm is based on an idea by George Marsaglia, tweaked by Don Mitchell and Jim Reeds, and further customized by Ken Thompson for Plan 9 and then Go. It has no official name, so this post calls it the Go 1 generator.&lt;/p&gt; &lt;p&gt;The goal is for these generators to be fast, repeatable, and random enough to support simulations, shuffling, and other non-cryptographic use cases. Repeatability is particularly important for uses like numerical simulations or randomized testing. For example, a randomized tester might pick a seed (perhaps based on the current time), generate a large random test input, and repeat. When the tester finds a failure, it only needs to print the seed to allow repeating the test with that specific large input.&lt;/p&gt; &lt;p&gt;Repeatability also matters over time: given a particular seed, a new version of Go needs to generate the same sequence of values that an older version did. We didn&amp;rsquo;t realize this when we released Go 1; instead, we discovered it the hard way, when we tried to make a change in Go 1.2 and got reports that we had broken certain tests and other use cases. At that point, we decided Go 1 compatibility included the specific random outputs for a given seed and &lt;a href="/change/5aca0514941ce7dd0f3cea8d8ffe627dbcd542ca"&gt;added a test&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;It is not a goal for these kinds of generators to produce random numbers suitable for deriving cryptographic keys or other important secrets. Because the seed is only 63 bits, any output drawn from the generator, no matter how long, will also only contain 63 bits of entropy. For example, using &lt;code&gt;math/rand&lt;/code&gt; to generate a 128-bit or 256-bit AES key would be a serious mistake, since the key would be easier to brute force. For that kind of use, you need a cryptographically strong random number generator, as provided by &lt;a href="/pkg/crypto/rand/"&gt;&lt;code&gt;crypto/rand&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;That&amp;rsquo;s enough background that we can move on to what needed fixing in the &lt;code&gt;math/rand&lt;/code&gt; package.&lt;/p&gt; &lt;h2 id="problems"&gt;Problems with &lt;code&gt;math/rand&lt;/code&gt;&lt;/h2&gt; &lt;p&gt;Over time, we noticed more and more problems with &lt;code&gt;math/rand&lt;/code&gt;. The most serious were the following.&lt;/p&gt; &lt;h3 id="problem.generator"&gt;Generator Algorithm&lt;/h3&gt; &lt;p&gt;The generator itself needed replacement.&lt;/p&gt; &lt;p&gt;The initial implementation of Go, while production ready, was in many ways a “pencil sketch” of the entire system, working well enough to serve as a base for future development: the compiler and runtime were written in C; the garbage collector was a conservative, single-threaded, stop-the-world collector; and the libraries used basic implementations throughout. From Go 1 through around Go 1.5, we went back and drew the “fully inked” version of each of these: we converted the compiler and runtime to Go; we wrote a new, precise, parallel, concurrent garbage collection with microsecond pause times; and we replaced standard library implementations with more sophisticated, optimized algorithms as needed.&lt;/p&gt; &lt;p&gt;Unfortunately, the repeatability requirement in &lt;code&gt;math/rand&lt;/code&gt; meant that we couldn&amp;rsquo;t replace the generator there without breaking compatibility. We were stuck with the Go 1 generator, which is reasonably fast (about 1.8ns per number on my M3 Mac) but maintains an internal state of almost 5 kilobytes. In contrast, Melissa O&amp;rsquo;Neill&amp;rsquo;s &lt;a href="https://www.pcg-random.org/" rel="noreferrer" target="_blank"&gt;PCG family of generators&lt;/a&gt; generates better random numbers in about 2.1ns per number with only 16 bytes of internal state. We also wanted to explore using Daniel J. Bernstein&amp;rsquo;s &lt;a href="https://cr.yp.to/chacha.html" rel="noreferrer" target="_blank"&gt;ChaCha stream cipher&lt;/a&gt; as a generator. A &lt;a href="/blog/chacha8rand"&gt;follow-up post&lt;/a&gt; discusses that generator specifically.&lt;/p&gt; &lt;h3 id="problem.source"&gt;Source Interface&lt;/h3&gt; &lt;p&gt;The &lt;a href="/pkg/math/rand/#Source"&gt;&lt;code&gt;rand.Source&lt;/code&gt; interface&lt;/a&gt; was wrong. That interface defines the concept of a low-level random number generator that generates non-negative &lt;code&gt;int64&lt;/code&gt; values:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;% go doc -src math/rand.Source package rand // import &amp;quot;math/rand&amp;quot; // A Source represents a source of uniformly-distributed // pseudo-random int64 values in the range [0, 1&amp;lt;&amp;lt;63). // // A Source is not safe for concurrent use by multiple goroutines. type Source interface { Int63() int64 Seed(seed int64) } func NewSource(seed int64) Source % &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;(In the doc comment, “[0, N)” denotes a &lt;a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Definitions_and_terminology" rel="noreferrer" target="_blank"&gt;half-open interval&lt;/a&gt;, meaning the range includes 0 but ends just before 2⁶³.)&lt;/p&gt; &lt;p&gt;The &lt;a href="/pkg/math/rand/#Rand"&gt;&lt;code&gt;rand.Rand&lt;/code&gt; type&lt;/a&gt; wraps a &lt;code&gt;Source&lt;/code&gt; to implement a richer set of operations, such as generating &lt;a href="/pkg/math/rand/#Rand.Intn"&gt;an integer between 0 and N&lt;/a&gt;, generating &lt;a href="/pkg/math/rand/#Rand.Float64"&gt;floating-point numbers&lt;/a&gt;, and so on.&lt;/p&gt; &lt;p&gt;We defined the &lt;code&gt;Source&lt;/code&gt; interface to return a shortened 63-bit value instead of a uint64 because that&amp;rsquo;s what the Go 1 generator and other widely-used generators produce, and it matches the convention set by the C standard library. But this was a mistake: more modern generators produce full-width uint64s, which is a more convenient interface.&lt;/p&gt; &lt;p&gt;Another problem is the &lt;code&gt;Seed&lt;/code&gt; method hard-coding an &lt;code&gt;int64&lt;/code&gt; seed: some generators are seeded by larger values, and the interface provides no way to handle that.&lt;/p&gt; &lt;h3 id="problem.seed"&gt;Seeding Responsibility&lt;/h3&gt; &lt;p&gt;A bigger problem with &lt;code&gt;Seed&lt;/code&gt; is that responsibility for seeding the global generator was unclear. Most users don&amp;rsquo;t use &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Rand&lt;/code&gt; directly. Instead, the &lt;code&gt;math/rand&lt;/code&gt; package provides a global generator accessed by top-level functions like &lt;a href="/pkg/math/rand/#Intn"&gt;&lt;code&gt;Intn&lt;/code&gt;&lt;/a&gt;. Following the C standard library, the global generator defaults to behaving as if &lt;code&gt;Seed(1)&lt;/code&gt; is called at startup. This is good for repeatability but bad for programs that want their random outputs to be different from one run to the next. The package documentation suggests using &lt;code&gt;rand.Seed(time.Now().UnixNano())&lt;/code&gt; in that case, to make the generator&amp;rsquo;s output time-dependent, but what code should do this?&lt;/p&gt; &lt;p&gt;Probably the main package should be in charge of how &lt;code&gt;math/rand&lt;/code&gt; is seeded: it would be unfortunate for imported libraries to configure global state themselves, since their choices might conflict with other libraries or the main package. But what happens if a library needs some random data and wants to use &lt;code&gt;math/rand&lt;/code&gt;? What if the main package doesn&amp;rsquo;t even know &lt;code&gt;math/rand&lt;/code&gt; is being used? We found that in practice many libraries add init functions that seed the global generator with the current time, “just to be sure”.&lt;/p&gt; &lt;p&gt;Library packages seeding the global generator themselves causes a new problem. Suppose package main imports two packages that both use &lt;code&gt;math/rand&lt;/code&gt;: package A assumes the global generator will be seeded by package main, but package B seeds it in an &lt;code&gt;init&lt;/code&gt; func. And suppose that package main doesn&amp;rsquo;t seed the generator itself. Now package A&amp;rsquo;s correct operation depends on the coincidence that package B is also imported in the program. If package main stops importing package B, package A will stop getting random values. We observed this happening in practice in large codebases.&lt;/p&gt; &lt;p&gt;In retrospect, it was clearly a mistake to follow the C standard library here: seeding the global generator automatically would remove the confusion about who seeds it, and users would stop being surprised by repeatable output when they didn&amp;rsquo;t want that.&lt;/p&gt; &lt;h3 id="problem.scale"&gt;Scalability&lt;/h3&gt; &lt;p&gt;The global generator also did not scale well. Because top-level functions like &lt;a href="/pkg/math/rand/#Intn"&gt;&lt;code&gt;rand.Intn&lt;/code&gt;&lt;/a&gt; can be called simultaneously from multiple goroutines, the implementation needed a lock protecting the shared generator state. In parallel usage, acquiring and releasing this lock was more expensive than the actual generation. It would make sense instead to have a per-thread generator state, but doing so would break repeatability in programs without concurrent use of &lt;code&gt;math/rand&lt;/code&gt;.&lt;/p&gt; &lt;h3 id="problem.rand"&gt;The &lt;code&gt;Rand&lt;/code&gt; implementation was missing important optimizations&lt;/h3&gt; &lt;p&gt;The &lt;a href="/pkg/math/rand/#Rand"&gt;&lt;code&gt;rand.Rand&lt;/code&gt; type&lt;/a&gt; wraps a &lt;code&gt;Source&lt;/code&gt; to implement a richer set of operations. For example, here is the Go 1 implementation of &lt;code&gt;Int63n&lt;/code&gt;, which returns a random integer in the range [0, &lt;code&gt;n&lt;/code&gt;).&lt;/p&gt; &lt;pre&gt;&lt;code&gt;func (r *Rand) Int63n(n int64) int64 { if n &amp;lt;= 0 { panic(&amp;quot;invalid argument to Int63n&amp;quot;) } max := int64((1&amp;lt;&amp;lt;63 - 1) - (1&amp;lt;&amp;lt;63)%uint64(n)) v := r.src.Int63() for v &amp;gt; max { v = r.Int63() } return v % n } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The actual conversion is easy: &lt;code&gt;v % n&lt;/code&gt;. However, no algorithm can convert 2⁶³ equally likely values into &lt;code&gt;n&lt;/code&gt; equally likely values unless 2⁶³ is a multiple of &lt;code&gt;n&lt;/code&gt;: otherwise some outputs will necessarily happen more often than others. (As a simpler example, try converting 4 equally likely values into 3.) The code computes &lt;code&gt;max&lt;/code&gt; such that &lt;code&gt;max+1&lt;/code&gt; is the largest multiple of &lt;code&gt;n&lt;/code&gt; less than or equal to 2⁶³, and then the loop rejects random values greater than or equal to &lt;code&gt;max+1&lt;/code&gt;. Rejecting these too-large values ensures that all &lt;code&gt;n&lt;/code&gt; outputs are equally likely. For small &lt;code&gt;n&lt;/code&gt;, needing to reject any value at all is rare; rejection becomes more common and more important for larger values. Even without the rejection loop, the two (slow) modulus operations can make the conversion more expensive than generating the random value &lt;code&gt;v&lt;/code&gt; in the first place.&lt;/p&gt; &lt;p&gt;In 2018, &lt;a href="https://arxiv.org/abs/1805.10941" rel="noreferrer" target="_blank"&gt;Daniel Lemire found an algorithm&lt;/a&gt; that avoids the divisions nearly all the time (see also his &lt;a href="https://lemire.me/blog/2019/06/06/nearly-divisionless-random-integer-generation-on-various-systems/" rel="noreferrer" target="_blank"&gt;2019 blog post&lt;/a&gt;). In &lt;code&gt;math/rand&lt;/code&gt;, adopting Lemire&amp;rsquo;s algorithm would make &lt;code&gt;Intn(1000)&lt;/code&gt; 20-30% faster, but we can&amp;rsquo;t: the faster algorithm generates different values than the standard conversion, breaking repeatability.&lt;/p&gt; &lt;p&gt;Other methods are also slower than they could be, constrained by repeatability. For example, the &lt;code&gt;Float64&lt;/code&gt; method could easily be sped up by about 10% if we could change the generated value stream. (This was the change we tried to make in Go 1.2 and rolled back, mentioned earlier.)&lt;/p&gt; &lt;h3 id="problem.read"&gt;The &lt;code&gt;Read&lt;/code&gt; Mistake&lt;/h3&gt; &lt;p&gt;As mentioned earlier, &lt;code&gt;math/rand&lt;/code&gt; is not intended for and not suitable for generating cryptographic secrets. The &lt;code&gt;crypto/rand&lt;/code&gt; package does that, and its fundamental primitive is its &lt;a href="/pkg/crypto/rand/#Read"&gt;&lt;code&gt;Read&lt;/code&gt; function&lt;/a&gt; and &lt;a href="/pkg/crypto/rand/#Reader"&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; variable.&lt;/p&gt; &lt;p&gt;In 2015, we accepted a proposal to make &lt;code&gt;rand.Rand&lt;/code&gt; implement &lt;code&gt;io.Reader&lt;/code&gt; as well, along with &lt;a href="/pkg/math/rand/#Read"&gt;adding a top-level &lt;code&gt;Read&lt;/code&gt; function&lt;/a&gt;. This seemed reasonable at the time, but in retrospect we did not pay enough attention to the software engineering aspects of this change. Now, if you want to read random data, you have two choices: &lt;code&gt;math/rand.Read&lt;/code&gt; and &lt;code&gt;crypto/rand.Read&lt;/code&gt;. If the data is going to be used for key material, it is very important to use &lt;code&gt;crypto/rand&lt;/code&gt;, but now it is possible to use &lt;code&gt;math/rand&lt;/code&gt; instead, potentially with disastrous consequences.&lt;/p&gt; &lt;p&gt;Tools like &lt;code&gt;goimports&lt;/code&gt; and &lt;code&gt;gopls&lt;/code&gt; have a special case to make sure they prefer to use &lt;code&gt;rand.Read&lt;/code&gt; from &lt;code&gt;crypto/rand&lt;/code&gt; instead of &lt;code&gt;math/rand&lt;/code&gt;, but that&amp;rsquo;s not a complete fix. It would be better to remove &lt;code&gt;Read&lt;/code&gt; entirely.&lt;/p&gt; &lt;h2 id="fix.v1"&gt;Fixing &lt;code&gt;math/rand&lt;/code&gt; directly&lt;/h2&gt; &lt;p&gt;Making a new, incompatible major version of a package is never our first choice: that new version only benefits programs that switch to it, leaving all existing usage of the old major version behind. In contrast, fixing a problem in the existing package has much more impact, since it fixes all the existing usage. We should never create a &lt;code&gt;v2&lt;/code&gt; without doing as much as possible to fix &lt;code&gt;v1&lt;/code&gt;. In the case of &lt;code&gt;math/rand&lt;/code&gt;, we were able to partly address a few of the problems described above:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Go 1.8 introduced an optional &lt;a href="/pkg/math/rand/#Uint64"&gt;&lt;code&gt;Source64&lt;/code&gt; interface&lt;/a&gt; with a &lt;code&gt;Uint64&lt;/code&gt; method. If a &lt;code&gt;Source&lt;/code&gt; also implements &lt;code&gt;Source64&lt;/code&gt;, then &lt;code&gt;Rand&lt;/code&gt; uses that method when appropriate. This “extension interface” pattern provides a compatible (if slightly awkward) way to revise an interface after the fact.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Go 1.20 automatically seeded the top-level generator and deprecated &lt;a href="/pkg/math/rand/#Seed"&gt;&lt;code&gt;rand.Seed&lt;/code&gt;&lt;/a&gt;. Although this may seem like an incompatible change given our focus on repeatability of the output stream, &lt;a href="/issue/56319"&gt;we reasoned&lt;/a&gt; that any imported package that called &lt;a href="/pkg/math/rand/#Int"&gt;&lt;code&gt;rand.Int&lt;/code&gt;&lt;/a&gt; at init time or inside any computation would also visibly change the output stream, and surely adding or removing such a call cannot be considered a breaking change. And if that&amp;rsquo;s true, then auto-seeding is no worse, and it would eliminate this source of fragility for future programs. We also added a &lt;a href="/doc/godebug"&gt;GODEBUG setting&lt;/a&gt; to opt back into the old behavior. Then we marked the top-level &lt;code&gt;rand.Seed&lt;/code&gt; as &lt;a href="/wiki/Deprecated"&gt;deprecated&lt;/a&gt;. (Programs that need seeded repeatability can still use &lt;code&gt;rand.New(rand.NewSource(seed))&lt;/code&gt; to obtain a local generator instead of using the global one.)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Having eliminated repeatability of the global output stream, Go 1.20 was also able to make the global generator scale better in programs that don&amp;rsquo;t call &lt;code&gt;rand.Seed&lt;/code&gt;, replacing the Go 1 generator with a very cheap per-thread &lt;a href="https://github.com/wangyi-fudan/wyhash" rel="noreferrer" target="_blank"&gt;wyrand generator&lt;/a&gt; already used inside the Go runtime. This removed the global mutex and made the top-level functions scale much better. Programs that do call &lt;code&gt;rand.Seed&lt;/code&gt; fall back to the mutex-protected Go 1 generator.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;We were able to adopt Lemire&amp;rsquo;s optimization in the Go runtime, and we also used it inside &lt;a href="/pkg/math/rand/#Shuffle"&gt;&lt;code&gt;rand.Shuffle&lt;/code&gt;&lt;/a&gt;, which was implemented after Lemire&amp;rsquo;s paper was published.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Although we couldn&amp;rsquo;t remove &lt;a href="/pkg/math/rand/#Read"&gt;&lt;code&gt;rand.Read&lt;/code&gt;&lt;/a&gt; entirely, Go 1.20 marked it &lt;a href="/wiki/Deprecated"&gt;deprecated&lt;/a&gt; in favor of &lt;code&gt;crypto/rand&lt;/code&gt;. We have since heard from people who discovered that they were accidentally using &lt;code&gt;math/rand.Read&lt;/code&gt; in cryptographic contexts when their editors flagged the use of the deprecated function.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;These fixes are imperfect and incomplete but also real improvements that helped all users of the existing &lt;code&gt;math/rand&lt;/code&gt; package. For more complete fixes, we needed to turn our attention to &lt;code&gt;math/rand/v2&lt;/code&gt;.&lt;/p&gt; &lt;h2 id="fix.v2"&gt;Fixing the rest in &lt;code&gt;math/rand/v2&lt;/code&gt;&lt;/h2&gt; &lt;p&gt;Defining &lt;code&gt;math/rand/v2&lt;/code&gt; took significant planning, then a &lt;a href="/issue/60751"&gt;GitHub Discussion&lt;/a&gt; and then a &lt;a href="/issue/61716"&gt;proposal discussion&lt;/a&gt;. It is the same as &lt;code&gt;math/rand&lt;/code&gt; with the following breaking changes addressing the problems outlined above:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;We removed the Go 1 generator entirely, replacing it with two new generators, &lt;a href="/pkg/math/rand/v2/#PCG"&gt;PCG&lt;/a&gt; and &lt;a href="/pkg/math/rand/v2/#ChaCha8"&gt;ChaCha8&lt;/a&gt;. The new types are named for their algorithms (avoiding the generic name &lt;code&gt;NewSource&lt;/code&gt;) so that if another important algorithm needs to be added, it will fit well into the naming scheme.&lt;/p&gt; &lt;p&gt;Adopting a suggestion from the proposal discussion, the new types implement the &lt;a href="/pkg/encoding/#BinaryMarshaler"&gt;&lt;code&gt;encoding.BinaryMarshaler&lt;/code&gt;&lt;/a&gt; and &lt;a href="/pkg/encoding/#BinaryUnmarshaler"&gt;&lt;code&gt;encoding.BinaryUnmarshaler&lt;/code&gt;&lt;/a&gt; interfaces.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;We changed the &lt;code&gt;Source&lt;/code&gt; interface, replacing the &lt;code&gt;Int63&lt;/code&gt; method with a &lt;code&gt;Uint64&lt;/code&gt; method and deleting the &lt;code&gt;Seed&lt;/code&gt; method. Implementations that support seeding can provide their own concrete methods, like &lt;a href="/pkg/math/rand/v2/#PCG.Seed"&gt;&lt;code&gt;PCG.Seed&lt;/code&gt;&lt;/a&gt; and &lt;a href="/pkg/math/rand/v2/#ChaCha8.Seed"&gt;&lt;code&gt;ChaCha8.Seed&lt;/code&gt;&lt;/a&gt;. Note that the two take different seed types, and neither is a single &lt;code&gt;int64&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;We removed the top-level &lt;code&gt;Seed&lt;/code&gt; function: the global functions like &lt;code&gt;Int&lt;/code&gt; can only be used in auto-seeded form now.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Removing the top-level &lt;code&gt;Seed&lt;/code&gt; also let us hard-code the use of scalable, per-thread generators by the top-level methods, avoiding a GODEBUG check at each use.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;We implemented Lemire&amp;rsquo;s optimization for &lt;code&gt;Intn&lt;/code&gt; and related functions. The concrete &lt;code&gt;rand.Rand&lt;/code&gt; API is now locked in to that value stream, so we will not be able to take advantage of any optimizations yet to be discovered, but at least we are up to date once again. We also implemented the &lt;code&gt;Float32&lt;/code&gt; and &lt;code&gt;Float64&lt;/code&gt; optimizations we wanted to use back in Go 1.2.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;During the proposal discussion, a contributor pointed out detectable bias in the implementations of &lt;code&gt;ExpFloat64&lt;/code&gt; and &lt;code&gt;NormFloat64&lt;/code&gt;. We fixed that bias and locked in the new value streams.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;code&gt;Perm&lt;/code&gt; and &lt;code&gt;Shuffle&lt;/code&gt; used different shuffling algorithms and produced different value streams, because &lt;code&gt;Shuffle&lt;/code&gt; happened second and used a faster algorithm. Deleting &lt;code&gt;Perm&lt;/code&gt; entirely would have made migration harder for users. Instead we implemented &lt;code&gt;Perm&lt;/code&gt; in terms of &lt;code&gt;Shuffle&lt;/code&gt;, which still lets us delete an implementation.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;We renamed &lt;code&gt;Int31&lt;/code&gt;, &lt;code&gt;Int63&lt;/code&gt;, &lt;code&gt;Intn&lt;/code&gt;, &lt;code&gt;Int31n&lt;/code&gt;, and &lt;code&gt;Int63n&lt;/code&gt; to &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;IntN&lt;/code&gt;, &lt;code&gt;Int32N&lt;/code&gt;, and &lt;code&gt;Int64N&lt;/code&gt;. The 31 and 63 in the names were unnecessarily pedantic and confusing, and the capitalized N is more idiomatic for a second “word” in the name in Go.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;We added &lt;code&gt;Uint&lt;/code&gt;, &lt;code&gt;Uint32&lt;/code&gt;, &lt;code&gt;Uint64&lt;/code&gt;, &lt;code&gt;UintN&lt;/code&gt;, &lt;code&gt;Uint32N&lt;/code&gt;, and &lt;code&gt;Uint64N&lt;/code&gt; top-level functions and methods. We needed to add &lt;code&gt;Uint64&lt;/code&gt; to provide direct access to the core &lt;code&gt;Source&lt;/code&gt; functionality, and it seemed inconsistent not to add the others.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Adopting another suggestion from the proposal discussion, we added a new top-level, generic function &lt;code&gt;N&lt;/code&gt; that is like &lt;code&gt;Int64N&lt;/code&gt; or &lt;code&gt;Uint64N&lt;/code&gt; but works for any integer type. In the old API, to create a random duration of up to 5 seconds, it was necessary to write:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;d := time.Duration(rand.Int63n(int64(5*time.Second))) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Using &lt;code&gt;N&lt;/code&gt;, the equivalent code is:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;d := rand.N(5 * time.Second) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;N&lt;/code&gt; is only a top-level function; there is no &lt;code&gt;N&lt;/code&gt; method on &lt;code&gt;rand.Rand&lt;/code&gt; because there are no generic methods in Go. (Generic methods are not likely in the future, either; they conflict badly with interfaces, and a complete implementation would require either run-time code generation or slow execution.)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;To ameliorate misuse of &lt;code&gt;math/rand&lt;/code&gt; in cryptographic contexts, we made &lt;code&gt;ChaCha8&lt;/code&gt; the default generator used in global functions, and we also changed the Go runtime to use it (replacing wyrand). Programs are still strongly encouraged to use &lt;code&gt;crypto/rand&lt;/code&gt; to generate cryptographic secrets, but accidentally using &lt;code&gt;math/rand/v2&lt;/code&gt; is not as catastrophic as using &lt;code&gt;math/rand&lt;/code&gt; would be. Even in &lt;code&gt;math/rand&lt;/code&gt;, the global functions now use the &lt;code&gt;ChaCha8&lt;/code&gt; generator when not explicitly seeded.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2 id="principles"&gt;Principles for evolving the Go standard library&lt;/h2&gt; &lt;p&gt;As mentioned at the start this post, one of the goals for this work was to establish principles and a pattern for how we approach all v2 packages in the standard library. There will not be a glut of v2 packages in the next few Go releases. Instead, we will handle one package at a time, making sure we set a quality bar that will last for another decade. Many packages will not need a v2 at all. But for those that do, our approach boils down to three principles.&lt;/p&gt; &lt;p&gt;First, a new, incompatible version of a package will use &lt;code&gt;that/package/v2&lt;/code&gt; as its import path, following &lt;a href="https://research.swtch.com/vgo-import" rel="noreferrer" target="_blank"&gt;semantic import versioning&lt;/a&gt; just like a v2 module outside the standard library would. This allows uses of the original package and the v2 package to coexist in a single program, which is critical for a &lt;a href="/talks/2016/refactor.article"&gt;gradual conversion&lt;/a&gt; to the new API.&lt;/p&gt; &lt;p&gt;Second, all changes must be rooted in respect for existing usage and users: we must not introduce needless churn, whether in the form of unnecessary changes to an existing package or an entirely new package that must be learned instead. In practice, that means we take the existing package as the starting point and only make changes that are well motivated and provide a value that justifies the cost to users of updating.&lt;/p&gt; &lt;p&gt;Third, the v2 package must not leave v1 users behind. Ideally, the v2 package should be able to do everything the v1 package could do, and when v2 is released, the v1 package should be rewritten to be a thin wrapper around v2. This would ensure that existing uses of v1 continue to benefit from bug fixes and performance optimizations in v2. Of course, given that v2 is introducing breaking changes, this is not always possible, but it is always something to consider carefully. For &lt;code&gt;math/rand/v2&lt;/code&gt;, we arranged for the auto-seeded v1 functions to call the v2 generator, but we were unable to share other code due to the repeatability violations. Ultimately &lt;code&gt;math/rand&lt;/code&gt; is not a lot of code and does not require regular maintenance, so the duplication is manageable. In other contexts, more work to avoid duplication could be worthwhile. For example, in the &lt;a href="/issue/63397"&gt;encoding/json/v2 design (still in progress)&lt;/a&gt;, although the default semantics and the API are changed, the package provides configuration knobs that make it possible to implement the v1 API. When we eventually ship &lt;code&gt;encoding/json/v2&lt;/code&gt;, &lt;code&gt;encoding/json&lt;/code&gt; (v1) will become a thin wrapper around it, ensuring that users who don&amp;rsquo;t migrate from v1 still benefit from optimizations and security fixes in v2.&lt;/p&gt; &lt;p&gt;A &lt;a href="/blog/chacha8rand"&gt;follow-up blog post&lt;/a&gt; presents the &lt;code&gt;ChaCha8&lt;/code&gt; generator in more detail.&lt;/p&gt; &lt;/div&gt; &lt;div class="Article prevnext"&gt; &lt;p&gt; &lt;b&gt;Next article: &lt;/b&gt;&lt;a href="/blog/chacha8rand"&gt;Secure Randomness in Go 1.22&lt;/a&gt;&lt;br&gt; &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href="/blog/survey2024-h1-results"&gt;Go Developer Survey 2024 H1 Results&lt;/a&gt;&lt;br&gt; &lt;b&gt;&lt;a href="/blog/all"&gt;Blog Index&lt;/a&gt;&lt;/b&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/js/jquery.js"&gt;&lt;/script&gt; &lt;script src="/js/playground.js"&gt;&lt;/script&gt; &lt;script src="/js/play.js"&gt;&lt;/script&gt; &lt;script src="/js/godocs.js"&gt;&lt;/script&gt;</content>
  </entry>
</feed>
