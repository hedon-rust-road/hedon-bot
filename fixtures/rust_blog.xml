<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
<link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml"/>
<link href="https://blog.rust-lang.org/" rel="alternate" type="text/html"/>
<id>https://blog.rust-lang.org/</id>
<title>Rust Blog</title>
<subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
<author>
<name>Maintained by the Rust Teams.</name>
<uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
</author>
<updated>2024-07-29T15:38:27+00:00</updated>
<entry>
<title>crates.io: development update</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/07/29/crates-io-development-update.html" type="text/html" title="crates.io: development update"/>
<published>2024-07-29T00:00:00+00:00</published>
<updated>2024-07-29T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/07/29/crates-io-development-update.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/07/29/crates-io-development-update.html"><p>Since crates.io does not have releases in the classical sense, there are no release notes either. However, the crates.io team still wants to keep you all updated about the ongoing development of crates.io. This blog post is a summary of the most significant changes that we have made to crates.io in the past months.</p> <h2><a href="#cargo-install" aria-hidden="true" class="anchor" id="cargo-install"></a><code>cargo install</code></h2> <p>When looking at crates like <a href="https://crates.io/crates/ripgrep">ripgrep</a> you will notice that the installation instructions now say <code>cargo install ripgrep</code> instead of <code>cargo add ripgrep</code>. We implemented this change to make it easier for users to install crates that have binary targets. <code>cargo add</code> is still the correct command to use when adding a crate as a dependency to your project, but for binary-only crates like ripgrep, <code>cargo install</code> is the way to go.</p> <p>We achieved this by analyzing the uploaded crate files when they are published to crates.io. If a crate has binary targets, the names of the binaries will now be saved in our database and then conveniently displayed on the crate page:</p> <p><img src="../../../images/2024-07-29-crates-io-development-update/cargo-install.png" alt="Dark Mode Screenshot" /></p> <p>After shipping this feature we got notified that some library crates use binaries for local development purposes and the author would prefer to not have the binaries listed on the crate page. The cargo team has been working on a <a href="https://github.com/rust-lang/cargo/pull/13713">solution</a> for this by using the <code>exclude</code> manifest field, which will be shipped soon.</p> <h2><a href="#dark-mode" aria-hidden="true" class="anchor" id="dark-mode"></a>Dark mode</h2> <p>If your operating system is set to dark mode, you may have noticed that crates.io now automatically switches to a dark user interface theme. If you don't like the dark theme, you can still switch back to the light theme by clicking the color theme icon in the top right corner of the page. By default, the theme will be set based on your operating system's theme settings, but you can also override this setting manually.</p> <p><img src="../../../images/2024-07-29-crates-io-development-update/dark-mode.png" alt="Dark Mode Screenshot" /></p> <p>Similar to GitHub, we now also have dark/light theme support for images in your <code>README.md</code> files:</p> <pre><code class="language-html">&lt;picture&gt; &lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;https://test.crates.io/logo_dark.svg&quot;&gt; &lt;img src=&quot;https://test.crates.io/logo.svg&quot; alt=&quot;logo&quot; width=&quot;200&quot;&gt; &lt;/picture&gt; </code></pre> <h2><a href="#rss-feeds" aria-hidden="true" class="anchor" id="rss-feeds"></a>RSS feeds</h2> <p>Inspired by our friends at the <a href="https://warehouse.pypa.io/api-reference/feeds.html">Python Package Index</a>, we have introduced a couple of experimental RSS feeds for crates.io:</p> <ul> <li><a href="https://static.crates.io/rss/crates.xml">https://static.crates.io/rss/crates.xml</a>: The latest new crates registered on crates.io (the past 60 minutes, but at least 50 new crates).</li> <li><a href="https://static.crates.io/rss/updates.xml">https://static.crates.io/rss/updates.xml</a>: The latest version updates on crates.io (the past 60 minutes, but at least 100 versions).</li> <li>e.g. <a href="https://static.crates.io/rss/crates/serde.xml">https://static.crates.io/rss/crates/serde.xml</a>: The latest version updates of the <code>serde</code> crate (the past 24 hours, but at least 10 versions).</li> </ul> <p>This will allow you to keep track of the latest crate releases and updates in your favorite RSS reader. The original GitHub issue requested a feed for all the crates you &quot;follow&quot; on crates.io, but we decided that per-crate feeds would be more useful for now. If you have any feedback on this feature, please let us know!</p> <h2><a href="#api-token-expiry-notifications" aria-hidden="true" class="anchor" id="api-token-expiry-notifications"></a>API token expiry notifications</h2> <p>Our crates.io team member <a href="https://github.com/hi-rustin">@hi-rustin</a> has been very active in improving our API tokens user experience. If you create an API token with an expiry date, you will now receive a notification email three days before the token expires. This will help you to remember to renew your token before it expires and your scripts stop working.</p> <p>Following this change, he also implemented a way to create new API tokens based on the configuration of existing tokens, which will make it much easier to renew tokens without having to reconfigure all the permissions. The user interface on the &quot;API tokens&quot; settings page now shows a &quot;Regenerate&quot; button, which will allow you to copy the permissions of existing tokens. Similarly, the token expiry notifications will now also contain a link that directly fills in the permissions of the expiring token, so you can easily create a new token with the same permissions.</p> <p><img src="../../../images/2024-07-29-crates-io-development-update/regenerate-button.png" alt="Dark Mode Screenshot" /></p> <h2><a href="#database-performance-optimizations" aria-hidden="true" class="anchor" id="database-performance-optimizations"></a>Database performance optimizations</h2> <p>Our latest addition to the crates.io team, <a href="https://github.com/eth3lbert">@eth3lbert</a>, has been working on optimizing the database queries that power crates.io. He has been working on a couple of pull requests that aim to reduce the load on the database server and make the website faster for everyone. Some of the changes he has made include:</p> <ul> <li><a href="https://github.com/rust-lang/crates.io/pull/7865">#7865</a>: Further speed-up reverse dependencies query</li> <li><a href="https://github.com/rust-lang/crates.io/pull/7941">#7941</a>: Improve crates endpoint performance</li> <li><a href="https://github.com/rust-lang/crates.io/pull/8734">#8734</a>: Add partial index on versions table</li> <li><a href="https://github.com/rust-lang/crates.io/pull/8737">#8737</a>: Improve the performance of reverse dependencies using the <code>default_versions</code> table</li> </ul> <p>In addition to that, we have recently migrated our database servers to a new provider with more memory and faster storage. This has also improved the performance of the website and allowed us to run more complex queries without running into performance issues. It was previously taking multiple seconds to load e.g. https://crates.io/crates/syn/reverse_dependencies, but now the server usually responds in much less than a second.</p> <p>Another piece of the puzzle was archiving old data that is no longer needed for the website. We have moved the download counts older than 90 days into CSV files that are stored on S3 and will soon be publicly available for download via our CDNs. This has reduced the size of the database significantly and improved the performance of some of our background jobs.</p> <h2><a href="#feedback" aria-hidden="true" class="anchor" id="feedback"></a>Feedback</h2> <p>We hope you enjoyed this update on the development of crates.io. If you have any feedback or questions, please let us know on <a href="https://rust-lang.zulipchat.com/#narrow/stream/318791-t-crates-io">Zulip</a> or <a href="https://github.com/rust-lang/crates.io/discussions">GitHub</a>. We are always happy to hear from you and are looking forward to your feedback!</p> </content>
<author>
<name>Tobias Bieniek</name>
</author>
</entry>
<entry>
<title>Announcing Rust 1.80.0</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html" type="text/html" title="Announcing Rust 1.80.0"/>
<published>2024-07-25T00:00:00+00:00</published>
<updated>2024-07-25T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html"><p>The Rust team is happy to announce a new version of Rust, 1.80.0. Rust is a programming language empowering everyone to build reliable and efficient software.</p> <p>If you have a previous version of Rust installed via <code>rustup</code>, you can get 1.80.0 with:</p> <pre><code class="language-console">$ rustup update stable </code></pre> <p>If you don't have it already, you can <a href="https://www.rust-lang.org/install.html">get <code>rustup</code></a> from the appropriate page on our website, and check out the <a href="https://doc.rust-lang.org/nightly/releases.html#version-1800-2024-07-25">detailed release notes for 1.80.0</a>.</p> <p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel (<code>rustup default beta</code>) or the nightly channel (<code>rustup default nightly</code>). Please <a href="https://github.com/rust-lang/rust/issues/new/choose">report</a> any bugs you might come across!</p> <h2><a href="#whats-in-1800-stable" aria-hidden="true" class="anchor" id="whats-in-1800-stable"></a>What's in 1.80.0 stable</h2> <h3><a href="#lazycell-and-lazylock" aria-hidden="true" class="anchor" id="lazycell-and-lazylock"></a><code>LazyCell</code> and <code>LazyLock</code></h3> <p>These &quot;lazy&quot; types delay the initialization of their data until first access. They are similar to the <code>OnceCell</code> and <code>OnceLock</code> types <a href="https://blog.rust-lang.org/2023/06/01/Rust-1.70.0.html#oncecell-and-oncelock">stabilized in 1.70</a>, but with the initialization function included in the cell. This completes the stabilization of functionality adopted into the standard library from the popular <a href="https://crates.io/crates/lazy-static"><code>lazy_static</code></a> and <a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crates.</p> <p><code>LazyLock</code> is the thread-safe option, making it suitable for places like <code>static</code> values. For example, both the <code>spawn</code> thread and the main <code>scope</code> will see the exact same duration below, since <code>LAZY_TIME</code> will be initialized once, by whichever ends up accessing the static first. Neither use has to know <em>how</em> to initialize it, unlike they would with <code>OnceLock::get_or_init()</code>.</p> <pre><code class="language-rust">use std::sync::LazyLock; use std::time::Instant; static LAZY_TIME: LazyLock&lt;Instant&gt; = LazyLock::new(Instant::now); fn main() { let start = Instant::now(); std::thread::scope(|s| { s.spawn(|| { println!(&quot;Thread lazy time is {:?}&quot;, LAZY_TIME.duration_since(start)); }); println!(&quot;Main lazy time is {:?}&quot;, LAZY_TIME.duration_since(start)); }); } </code></pre> <p><code>LazyCell</code> does the same thing without thread synchronization, so it doesn't implement <code>Sync</code>, which is needed for <code>static</code>, but it can still be used in <code>thread_local!</code> statics (with distinct initialization per thread). Either type can also be used in other data structures as well, depending on thread-safety needs, so lazy initialization is available everywhere!</p> <h3><a href="#checked-cfg-names-and-values" aria-hidden="true" class="anchor" id="checked-cfg-names-and-values"></a>Checked <code>cfg</code> names and values</h3> <p>In 1.79, <code>rustc</code> stabilized a <a href="https://doc.rust-lang.org/rustc/check-cfg.html"><code>--check-cfg</code> flag</a>, and now Cargo 1.80 is enabling those checks for all <code>cfg</code> names and values that it knows (in addition to the <a href="https://doc.rust-lang.org/rustc/check-cfg.html#well-known-names-and-values">well known names and values</a> from <code>rustc</code>). This includes feature names from <code>Cargo.toml</code> as well as new <code>cargo::rustc-check-cfg</code> output from build scripts.</p> <p>Unexpected cfgs are reported by the warn-by-default <code>unexpected_cfgs</code> lint, which is meant to catch typos or other misconfiguration. For example, in a project with an optional <code>rayon</code> dependency, this code is configured for the wrong <code>feature</code> value:</p> <pre><code class="language-rust">fn main() { println!(&quot;Hello, world!&quot;); #[cfg(feature = &quot;crayon&quot;)] rayon::join( || println!(&quot;Hello, Thing One!&quot;), || println!(&quot;Hello, Thing Two!&quot;), ); } </code></pre> <pre><code class="language-console">warning: unexpected `cfg` condition value: `crayon` --&gt; src/main.rs:4:11 | 4 | #[cfg(feature = &quot;crayon&quot;)] | ^^^^^^^^^^-------- | | | help: there is a expected value with a similar name: `&quot;rayon&quot;` | = note: expected values for `feature` are: `rayon` = help: consider adding `crayon` as a feature in `Cargo.toml` = note: see &lt;https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html&gt; for more information about checking conditional configuration = note: `#[warn(unexpected_cfgs)]` on by default </code></pre> <p>The same warning is reported regardless of whether the actual <code>rayon</code> feature is enabled or not.</p> <p>The <code>[lints]</code> table in the <code>Cargo.toml</code> manifest can also be used to extend the list of known names and values for custom <code>cfg</code>. <code>rustc</code> automatically provides <a href="https://doc.rust-lang.org/rustc/check-cfg.html#specifying-expected-names-and-values">the syntax</a> to use in the warning.</p> <pre><code class="language-toml">[lints.rust] unexpected_cfgs = { level = &quot;warn&quot;, check-cfg = ['cfg(foo, values(&quot;bar&quot;))'] } </code></pre> <p>You can read more about this feature in a <a href="https://blog.rust-lang.org/2024/05/06/check-cfg.html">previous blog post</a> announcing the availability of the feature on nightly.</p> <h3><a href="#exclusive-ranges-in-patterns" aria-hidden="true" class="anchor" id="exclusive-ranges-in-patterns"></a>Exclusive ranges in patterns</h3> <p>Rust ranged patterns can now use exclusive endpoints, written <code>a..b</code> or <code>..b</code> similar to the <code>Range</code> and <code>RangeTo</code> expression types. For example, the following patterns can now use the same constants for the end of one pattern and the start of the next:</p> <pre><code class="language-rust">pub fn size_prefix(n: u32) -&gt; &amp;'static str { const K: u32 = 10u32.pow(3); const M: u32 = 10u32.pow(6); const G: u32 = 10u32.pow(9); match n { ..K =&gt; &quot;&quot;, K..M =&gt; &quot;k&quot;, M..G =&gt; &quot;M&quot;, G.. =&gt; &quot;G&quot;, } } </code></pre> <p>Previously, only inclusive (<code>a..=b</code> or <code>..=b</code>) or open (<code>a..</code>) ranges were allowed in patterns, so code like this would require separate constants for inclusive endpoints like <code>K - 1</code>.</p> <p>Exclusive ranges have been implemented as an unstable feature for a long time, but the blocking concern was that they might add confusion and increase the chance of off-by-one errors in patterns. To that end, exhaustiveness checking has been enhanced to better detect gaps in pattern matching, and new lints <code>non_contiguous_range_endpoints</code> and <code>overlapping_range_endpoints</code> will help detect cases where you might want to switch exclusive patterns to inclusive, or vice versa.</p> <h3><a href="#stabilized-apis" aria-hidden="true" class="anchor" id="stabilized-apis"></a>Stabilized APIs</h3> <ul> <li><a href="https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html#impl-Default-for-Rc%3CCStr%3E"><code>impl Default for Rc&lt;CStr&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html#impl-Default-for-Rc%3Cstr%3E"><code>impl Default for Rc&lt;str&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html#impl-Default-for-Rc%3C%5BT%5D%3E"><code>impl Default for Rc&lt;[T]&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#impl-Default-for-Arc%3Cstr%3E"><code>impl Default for Arc&lt;str&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#impl-Default-for-Arc%3CCStr%3E"><code>impl Default for Arc&lt;CStr&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#impl-Default-for-Arc%3C%5BT%5D%3E"><code>impl Default for Arc&lt;[T]&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#impl-IntoIterator-for-Box%3C%5BI%5D,+A%3E"><code>impl IntoIterator for Box&lt;[T]&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#impl-FromIterator%3CString%3E-for-Box%3Cstr%3E"><code>impl FromIterator&lt;String&gt; for Box&lt;str&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#impl-FromIterator%3Cchar%3E-for-Box%3Cstr%3E"><code>impl FromIterator&lt;char&gt; for Box&lt;str&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/cell/struct.LazyCell.html"><code>LazyCell</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/sync/struct.LazyLock.html"><code>LazyLock</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_duration_f32"><code>Duration::div_duration_f32</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_duration_f64"><code>Duration::div_duration_f64</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.take_if"><code>Option::take_if</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/trait.Seek.html#method.seek_relative"><code>Seek::seek_relative</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.as_slice"><code>BinaryHeap::as_slice</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.offset"><code>NonNull::offset</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.byte_offset"><code>NonNull::byte_offset</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.add"><code>NonNull::add</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.byte_add"><code>NonNull::byte_add</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.sub"><code>NonNull::sub</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.byte_sub"><code>NonNull::byte_sub</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.offset_from"><code>NonNull::offset_from</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.byte_offset_from"><code>NonNull::byte_offset_from</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.read"><code>NonNull::read</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.read_volatile"><code>NonNull::read_volatile</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.read_unaligned"><code>NonNull::read_unaligned</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.write"><code>NonNull::write</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.write_volatile"><code>NonNull::write_volatile</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.write_unaligned"><code>NonNull::write_unaligned</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.write_bytes"><code>NonNull::write_bytes</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.copy_to"><code>NonNull::copy_to</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.copy_to_nonoverlapping"><code>NonNull::copy_to_nonoverlapping</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.copy_from"><code>NonNull::copy_from</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.copy_from_nonoverlapping"><code>NonNull::copy_from_nonoverlapping</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.replace"><code>NonNull::replace</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.swap"><code>NonNull::swap</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.drop_in_place"><code>NonNull::drop_in_place</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.align_offset"><code>NonNull::align_offset</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_checked"><code>&lt;[T]&gt;::split_at_checked</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_mut_checked"><code>&lt;[T]&gt;::split_at_mut_checked</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_at_checked"><code>str::split_at_checked</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_at_mut_checked"><code>str::split_at_mut_checked</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim_ascii"><code>str::trim_ascii</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim_ascii_start"><code>str::trim_ascii_start</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim_ascii_end"><code>str::trim_ascii_end</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.trim_ascii"><code>&lt;[u8]&gt;::trim_ascii</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.trim_ascii_start"><code>&lt;[u8]&gt;::trim_ascii_start</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.trim_ascii_end"><code>&lt;[u8]&gt;::trim_ascii_end</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/net/struct.Ipv4Addr.html#associatedconstant.BITS"><code>Ipv4Addr::BITS</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/net/struct.Ipv4Addr.html#method.to_bits"><code>Ipv4Addr::to_bits</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/net/struct.Ipv4Addr.html#method.from_bits"><code>Ipv4Addr::from_bits</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/net/struct.Ipv6Addr.html#associatedconstant.BITS"><code>Ipv6Addr::BITS</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/net/struct.Ipv6Addr.html#method.to_bits"><code>Ipv6Addr::to_bits</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/net/struct.Ipv6Addr.html#method.from_bits"><code>Ipv6Addr::from_bits</code></a></li> <li><a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_flattened"><code>Vec::&lt;[T; N]&gt;::into_flattened</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.as_flattened"><code>&lt;[[T; N]]&gt;::as_flattened</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.as_flattened_mut"><code>&lt;[[T; N]]&gt;::as_flattened_mut</code></a></li> </ul> <p>These APIs are now stable in const contexts:</p> <ul> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.last_chunk"><code>&lt;[T]&gt;::last_chunk</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.new"><code>BinaryHeap::new</code></a></li> </ul> <h3><a href="#other-changes" aria-hidden="true" class="anchor" id="other-changes"></a>Other changes</h3> <p>Check out everything that changed in <a href="https://github.com/rust-lang/rust/releases/tag/1.80.0">Rust</a>, <a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-180-2024-07-25">Cargo</a>, and <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-180">Clippy</a>.</p> <h2><a href="#contributors-to-1800" aria-hidden="true" class="anchor" id="contributors-to-1800"></a>Contributors to 1.80.0</h2> <p>Many people came together to create Rust 1.80.0. We couldn't have done it without all of you. <a href="https://thanks.rust-lang.org/rust/1.80.0/">Thanks!</a></p> </content>
<author>
<name>The Rust Release Team</name>
</author>
</entry>
<entry>
<title>Types Team Update and Roadmap</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/06/26/types-team-update.html" type="text/html" title="Types Team Update and Roadmap"/>
<published>2024-06-26T00:00:00+00:00</published>
<updated>2024-06-26T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/06/26/types-team-update.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/06/26/types-team-update.html"><p>It has been more than a year since <a href="https://blog.rust-lang.org/2023/01/20/types-announcement.html">the initial blog post</a> announcing the Types team, and our initial set of goals. For details on what the team is, why it was formed, or our previously-stated overarching goals, go check out that blog post. In short the Types team's purview extends to the parts of the Rust language and compiler that involve the type system, e.g. type checking, trait solving, and borrow checking. Our short and long term goals effectively work to make the type system sound, consistent, extensible, and fast.</p> <p>Before getting into details, it's worth sharing a quick point: the team over the last year has been very successful. Oftentimes, it's hard to measure impact, particularly when long-term roadmap goals are hard to quantify progress on and various short-term goals either are hit or aren't. But, there is one clear statistic that is somewhat indicative of the team's progress: over the last year or so, <a href="https://github.com/rust-lang/rust/pulls?q=is%3Apr+label%3AT-types+label%3Adisposition-merge+is%3Amerged+closed%3A%3E2023-01-20+sort%3Acreated-asc+">more than 50 user-facing changes</a> have landed, each separately approved by Types Team consensus through FCP.</p> <p>The changes lie at the boundary between language design and implementation, and the Types Team (which is a subteam of both the Language and Compiler Teams) existing means that not only does the Rust Project have the bandwidth to make these decisions but we also have enough people with the knowledge and experience of the type system to make informed decisions that overall make the language better.</p> <h2><a href="#the-priorities-of-the-types-team" aria-hidden="true" class="anchor" id="the-priorities-of-the-types-team"></a>The priorities of the types team</h2> <p>To evaluate our progress over the last year and our roadmap going forward, lets start with our main priorities in order of importance. We will refer to them during the remainder of this post. To reach our goals, we need a a healthy group of maintainers which have the expertise and capacity to react to issues and to implement complex changes.</p> <h3><a href="#the-type-system-should-be-sound" aria-hidden="true" class="anchor" id="the-type-system-should-be-sound"></a>The type system should be Sound</h3> <p>One of the main promises of Rust is that there cannot be undefined behavior when using only safe code. It might surprise you that there are currently <a href="https://github.com/orgs/rust-lang/projects/44/views/1">known type system bugs</a> which break these guarantees. Most of these issues were found by people familiar with the inner workings of the compiler by explicitly looking for them and we generally do not expect users to encounter these bugs by accident. Regardless, we deeply care about fixing them and are working towards a fully sound and ideally verified type system.</p> <h3><a href="#the-type-system-should-be-consistent" aria-hidden="true" class="anchor" id="the-type-system-should-be-consistent"></a>The type system should be Consistent</h3> <p>The type system should be easy to reason about. We should avoid rough edges and special-cases if possible. We want to keep both the implementation and user-facing behavior as simple as possible. Where possible we want to consider the overall design instead of providing local targeted fixes. This is necessary to build trust in the soundness of the type system and allows for a simpler mental model of Rust.</p> <h3><a href="#the-type-system-should-be-extensible" aria-hidden="true" class="anchor" id="the-type-system-should-be-extensible"></a>The type system should be Extensible</h3> <p>Rust is still evolving and we will be required to extend the type system to enable new language features going forward. This requires the type system to be extensible and approachable. The design of the language should not be adapted to work around short-comings of its current type system implementation. We should collaborate with other teams and users to make sure we're aware of their problems and consider possible future extensions in our implementation and design.</p> <h3><a href="#the-type-system-should-be-fast" aria-hidden="true" class="anchor" id="the-type-system-should-be-fast"></a>The type system should be Fast</h3> <p>We care about the compile times of Rust and want to consider the impact on compile times of our designs. We should look for effective approaches to speed up the existing implementation, by improving caching or adding fast paths where applicable. We should also be aware of the compile time impact of future additions to the type system and suggest more performant solutions where possible.</p> <h2><a href="#updates" aria-hidden="true" class="anchor" id="updates"></a>Updates</h2> <p>We have been very active over the last year and made some significant progress. There are also a few non-technical updates we would like to share.</p> <h2><a href="#organizational-updates" aria-hidden="true" class="anchor" id="organizational-updates"></a>Organizational updates</h2> <p>First, a huge welcome to the two new members to team since the announcement post: <a href="https://github.com/boxyuwu">@BoxyUwU</a> and <a href="https://github.com/aliemjay">@aliemjay</a>. <a href="https://github.com/boxyuwu">@BoxyUwU</a> has been doing a lot of work on const generics and made significant contributions to the design of the next generation trait solver. <a href="https://github.com/aliemjay">@aliemjay</a> has been working on some very subtle improvements to opaque types - <code>impl Trait</code> - and to borrow checking. They are both invaluable additions to the team.</p> <p>We also organized another in-person Types Team meetup last October, immediately prior to EuroRust. We discussed the state of the team, looked at current implementation challenges and in-progress work, and reviewed and updated <a href="https://blog.rust-lang.org/2023/01/20/types-announcement.html#roadmap">the roadmap from the previous meetup</a>. Most of this will be covered in this blog post.</p> <p>Finally, as discussed in the <a href="https://rust-lang.github.io/rfcs/3254-types-team.html">RFC</a>, we would like to have leads rotate out regularly, largely to help share the burden and experience of leads' work. So with that being said, <a href="https://github.com/nikomatsakis">@nikomatsakis</a> is rotating out and <a href="https://github.com/lcnr">@lcnr</a> is joining to co-lead alongside <a href="https://github.com/jackh726/">@jackh726</a>.</p> <h2><a href="#roadmap-progress-and-major-milestones" aria-hidden="true" class="anchor" id="roadmap-progress-and-major-milestones"></a>Roadmap progress and major milestones</h2> <h3><a href="#the-next-generation-trait-solver" aria-hidden="true" class="anchor" id="the-next-generation-trait-solver"></a>The next-generation trait solver</h3> <p>There has been <a href="https://github.com/rust-lang/rust/pulls?q=is%3Apr+label%3AWG-trait-system-refactor+-label%3Arollup+is%3Amerged+closed%3A%3E2023-01-20+sort%3Acreated-asc+">a lot of work</a> on the <a href="https://github.com/rust-lang/trait-system-refactor-initiative/">next-generation trait solver</a>. The initiative posted <a href="https://blog.rust-lang.org/inside-rust/2023/12/22/trait-system-refactor-initiative.html">a separate update</a> at the end of last year. While we would have liked to <a href="https://github.com/rust-lang/rust/pull/121848">stabilize its use in coherence</a> a few months ago, this surfaced additional small behavior regressions and hangs, causing delays. We are working on fixing these issues and intend to merge the stabilization PR soon. We are getting close to compiling the standard library and the compiler with the new solver enabled everywhere, after which will be able to run crater to figure out the remaining issues. We expect there to be a long tail of minor issues and behavioral differences from the existing implementation, so there's still a lot to do here. There are also open design questions which we will have to resolve before stabilizing the new implementation.</p> <h3><a href="#async-and-impl-trait" aria-hidden="true" class="anchor" id="async-and-impl-trait"></a>Async and <code>impl Trait</code></h3> <p>We stabilized <code>async</code>-fn in traits (AFIT) and return-position <code>impl Trait</code> in traits (RPITIT) in version 1.75 thanks to a significant effort by <a href="https://github.com/compiler-errors">@compiler-errors</a> and <a href="https://github.com/spastorino">@spastorino</a>. <a href="https://github.com/cjgillot">@cjgillot</a> greatly improved the way generators, and therefore async functions, are represented in the type system<sup class="footnote-ref"><a href="#fn-107421" id="fnref-107421" data-footnote-ref>1</a></sup>. This allowed us to support recursive <code>async</code>-functions without too much additional work<sup class="footnote-ref"><a href="#fn-117703" id="fnref-117703" data-footnote-ref>2</a></sup>.</p> <p>Designing the next-generation trait solver surfaced issues and future-compatibility challenges of our type-alias <code>impl Trait</code> (TAIT) implementation using the old trait solver. We are currently reworking the design and implementation. <a href="https://github.com/oli-obk">@oli-obk</a> is spear-heading this effort. This also impacts RPIT edge-cases, forcing us to be careful to avoid accidental breakage. There are some open language design questions for TAIT, so we plan to stabilize associated type position <code>impl Trait</code> (ATPIT) as it avoids these language design questions while still closing the expressiveness gap.</p> <h3><a href="#a-mir-formality" aria-hidden="true" class="anchor" id="a-mir-formality"></a><code>a-mir-formality</code></h3> <p>We made limited progress on <a href="https://github.com/rust-lang/a-mir-formality"><code>a-mir-formality</code></a> over the last year, mostly because we were able to allocate less time than expected towards this work. We have used it as the foundation towards an intuitive approach to coinductive traits which are necessary for many of the remaining unsound issues.</p> <h3><a href="#fixing-soundness-issues" aria-hidden="true" class="anchor" id="fixing-soundness-issues"></a>Fixing soundness issues</h3> <p>We fixed multiple long-standing unsound issues, see <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+label%3AI-unsound+label%3AT-types+-label%3Arequires-nightly+is%3Aclosed+closed%3A%3C2024-06-20+">the full list of closed issues</a>. The most most notable of which was <a href="https://github.com/rust-lang/rust/issues/80176">#80176</a>. This subtle issue caused us to accept methods in trait implementations whose function signature had outlives requirements not present in the trait definition. These requirements were then never proven when calling the trait method. As there were some crates which relied on this pattern by accident, even if it their usages didn't exploit this unsoundness, we first merged a <a href="https://github.com/rust-lang/rust/issues/105572">future-compatibility lint</a> which we then moved to a hard error after a few versions.</p> <p>We've also spent time on <a href="https://github.com/orgs/rust-lang/projects/44/views/1">categorizing the remaining open issues</a> and integrating them into our longterm planning. Most of the remaining ones are blocked on the next-generation trait solver as fixing them relies on coinductive trait semantics and improvements to implied bounds. There are some remaining issues which can be at least partially fixed right now, and we intend to work through them as we go. Finally, there are some issues for which we still haven't figured out the best approach and which require some further considerations.</p> <h2><a href="#going-forward" aria-hidden="true" class="anchor" id="going-forward"></a>Going forward</h2> <p>We made significant progress during the last year but we are not done! This section covers our goals for the rest of 2024. For each item we also link to the project goals that we have proposed as part of the Rust Project's <a href="https://blog.rust-lang.org/inside-rust/2024/05/07/announcing-project-goals.html">experimental new roadmap process</a>.</p> <h3><a href="#-znext-solver" aria-hidden="true" class="anchor" id="-znext-solver"></a><code>-Znext-solver</code></h3> <ul> <li><a href="https://rust-lang.github.io/rust-project-goals/2024h2/next-solver.html">Next-generation trait solver project goal</a></li> </ul> <p>Our biggest goal is to use the <a href="https://github.com/rust-lang/trait-system-refactor-initiative/">next-generation trait solver</a> everywhere by default and to fully replace the existing implementation. We are currently finalizing the stabilization of <a href="https://github.com/rust-lang/rust/pull/121848">its use in coherence checking</a>. This should already fix multiple unsound issues and fix a lot of smaller issues and inconsistencies of the current implementation. See the stabilization report for more details.</p> <p>We are also working on extracting its implementation into a separate library outside of the compiler itself. We would like to share the trait solver with rust-analyzer by the end of this year. They currently use <a href="https://github.com/rust-lang/chalk/">chalk</a> which is no longer actively maintained. Using the next-generation trait solver in rust-analyzer should result in a lot of additional testing for the solver while also improving the IDE experience by positively impacting performance and correctness.</p> <p>We intend to slowly roll out the solver in other areas of the compiler until we're able to fully remove the existing implementation by the end of 2025. This switch will fix multiple unsound issues by itself and will unblock a significant amount of future work. It will generally cleanup many rough edges of the type system, such as associated types in higher-ranked types. There are many unsound issues which can only be fixed once we exclusively use the new implementation.</p> <h3><a href="#a-mir-formality-1" aria-hidden="true" class="anchor" id="a-mir-formality-1"></a><code>a-mir-formality</code></h3> <ul> <li><a href="https://rust-lang.github.io/rust-project-goals/2024h2/a-mir-formality.html"><code>a-mir-formality</code> project goal</a></li> </ul> <p>We intend to more actively develop <code>a-mir-formality</code> this year to use it in our design process. Using it to model parts of the type system has already been incredibly impactful and we want to build on that. We are working on more effective testing of <code>a-mir-formality</code> by enabling its use for actual Rust code snippets and by adding fuzzing support. This will allow us to gain additional confidence in our model of the type system and will guide its future development.</p> <p>We plan to fully formalize some components of the type system this year. Coherence is fairly self-contained, very subtle, and soundness-critical. This has prevented us from making significant improvements to it in the past. We also intend to formalize coinductive trait semantics, which are difficult to reason about and necessary to fix many longstanding soundness issues.</p> <h3><a href="#language-changes-and-polonius" aria-hidden="true" class="anchor" id="language-changes-and-polonius"></a>Language changes and polonius</h3> <ul> <li><a href="https://rust-lang.github.io/rust-project-goals/2024h2/ATPIT.html">Associated Type Position Impl Trait (ATPIT) project goal</a></li> <li><a href="https://rust-lang.github.io/rust-project-goals/2024h2/Polonius.html">Polonius on Nightly project goal</a></li> </ul> <p>We intend to get the internal implementation of opaque types ready for the stabilization of TAIT and ATPIT this year. We are also hoping to land significant improvements to our handling of associated types in coherence checking this year.</p> <p>Our other goal is to get <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius</a>, the next generation borrow checker, available on nightly, which would put us in a position to stabilize in 2025 once we have time to do more optimization and testing.</p> <p>We also intend to support the development of other language features, such as <code>async</code>-closures, which are part of the <a href="https://rust-lang.github.io/rust-project-goals/2024h2/async.html">async project goal</a>, and <code>dyn</code>-trait upcasting, which will hopefully get stabilized in the near future.</p> <h2><a href="#roadmap" aria-hidden="true" class="anchor" id="roadmap"></a>Roadmap</h2> <h3><a href="#eoy-2024" aria-hidden="true" class="anchor" id="eoy-2024"></a>EOY 2024</h3> <ul> <li>next-generation trait solver <ul> <li>stable in coherence</li> <li>used by rust-analyzer</li> </ul> </li> <li>ATPIT stabilized</li> <li>a-mir-formality <ul> <li>support for fuzzing and testing Rust snippets</li> <li>complete model of coherence and coinductive trait semantics</li> </ul> </li> <li>full polonius implementation available on nightly</li> </ul> <h3><a href="#eoy-2025" aria-hidden="true" class="anchor" id="eoy-2025"></a>EOY 2025</h3> <ul> <li>next-generation trait solver used everywhere by default</li> <li>TAIT stabilized</li> <li>polonius stabilized</li> </ul> <h2><a href="#eoy-2027" aria-hidden="true" class="anchor" id="eoy-2027"></a>EOY 2027</h2> <ul> <li>next-generation trait solver <ul> <li>support for coinduction and (implicit) where-bounds on <code>for&lt;'a&gt;</code></li> <li>enable perfect derive</li> </ul> </li> <li>a-mir-formality fully model soundness critical parts of Rust</li> <li>all known type system unsoundnesses fixed</li> </ul> <section class="footnotes" data-footnotes> <ol> <li id="fn-107421"> <p>stabilized in <a href="https://github.com/rust-lang/rust/issues/107421">https://github.com/rust-lang/rust/issues/107421</a> <a href="#fnref-107421" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="1" aria-label="Back to reference 1">↩</a></p> </li> <li id="fn-117703"> <p>stabilized in <a href="https://github.com/rust-lang/rust/issues/117703">https://github.com/rust-lang/rust/issues/117703</a> <a href="#fnref-117703" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="2" aria-label="Back to reference 2">↩</a></p> </li> </ol> </section> </content>
<author>
<name>lcnr</name>
</author>
</entry>
<entry>
<title>Announcing Rust 1.79.0</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html" type="text/html" title="Announcing Rust 1.79.0"/>
<published>2024-06-13T00:00:00+00:00</published>
<updated>2024-06-13T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html"><p>The Rust team is happy to announce a new version of Rust, 1.79.0. Rust is a programming language empowering everyone to build reliable and efficient software.</p> <p>If you have a previous version of Rust installed via <code>rustup</code>, you can get 1.79.0 with:</p> <pre><code class="language-console">$ rustup update stable </code></pre> <p>If you don't have it already, you can <a href="https://www.rust-lang.org/install.html">get <code>rustup</code></a> from the appropriate page on our website, and check out the <a href="https://doc.rust-lang.org/nightly/releases.html#version-1790-2024-06-13">detailed release notes for 1.79.0</a>.</p> <p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel (<code>rustup default beta</code>) or the nightly channel (<code>rustup default nightly</code>). Please <a href="https://github.com/rust-lang/rust/issues/new/choose">report</a> any bugs you might come across!</p> <h2><a href="#whats-in-1790-stable" aria-hidden="true" class="anchor" id="whats-in-1790-stable"></a>What's in 1.79.0 stable</h2> <h3><a href="#inline-const-expressions" aria-hidden="true" class="anchor" id="inline-const-expressions"></a>Inline <code>const</code> expressions</h3> <p><code>const { ... }</code> blocks are now stable in expression position, permitting explicitly entering a const context without requiring extra declarations (e.g., defining <code>const</code> items or associated constants on a trait).</p> <p>Unlike const items (<code>const ITEM: ... = ...</code>), inline consts are able to make use of in-scope generics, and have their type inferred rather than written explicitly, making them particularly useful for inline code snippets. For example, a pattern like:</p> <pre><code class="language-rust">const EMPTY: Option&lt;Vec&lt;u8&gt;&gt; = None; let foo = [EMPTY; 100]; </code></pre> <p>can now be written like this:</p> <pre><code class="language-rust">let foo = [const { None }; 100]; </code></pre> <p>Notably, this is also true of generic contexts, where previously a verbose trait declaration with an associated constant would be required:</p> <pre><code class="language-rust">fn create_none_array&lt;T, const N: usize&gt;() -&gt; [Option&lt;T&gt;; N] { [const { None::&lt;T&gt; }; N] } </code></pre> <p>This makes this code much more succinct and easier to read.</p> <p>See the <a href="https://doc.rust-lang.org/nightly/reference/expressions/block-expr.html#const-blocks">reference documentation</a> for details.</p> <h3><a href="#bounds-in-associated-type-position" aria-hidden="true" class="anchor" id="bounds-in-associated-type-position"></a>Bounds in associated type position</h3> <p>Rust 1.79 stabilizes the associated item bounds syntax, which allows us to put bounds in associated type position within other bounds, i.e. <code>T: Trait&lt;Assoc: Bounds...&gt;</code>. This avoids the need to provide an extra, explicit generic type just to constrain the associated type.</p> <p>This feature allows specifying bounds in a few places that previously either were not possible or imposed extra, unnecessary constraints on usage:</p> <ul> <li><strong><code>where</code> clauses</strong> - in this position, this is equivalent to breaking up the bound into two (or more) <code>where</code> clauses. For example, <code>where T: Trait&lt;Assoc: Bound&gt;</code> is equivalent to <code>where T: Trait, &lt;T as Trait&gt;::Assoc: Bound</code>.</li> <li><strong>Supertraits</strong> - a bound specified via the new syntax is implied when the trait is used, unlike where clauses. Sample syntax: <code>trait CopyIterator: Iterator&lt;Item: Copy&gt; {}</code>.</li> <li><strong>Associated type item bounds</strong> - This allows constraining the <em>nested</em> rigid projections that are associated with a trait's associated types. e.g. <code>trait Trait { type Assoc: Trait2&lt;Assoc2: Copy&gt;; }</code>.</li> <li><strong>opaque type bounds (RPIT, TAIT)</strong> - This allows constraining associated types that are associated with the opaque type without having to <em>name</em> the opaque type. For example, <code>impl Iterator&lt;Item: Copy&gt;</code> defines an iterator whose item is <code>Copy</code> without having to actually name that item bound.</li> </ul> <p>See <a href="https://github.com/rust-lang/rust/pull/122055/#issue-2170532454">the stabilization report</a> for more details.</p> <h3><a href="#extending-automatic-temporary-lifetime-extension" aria-hidden="true" class="anchor" id="extending-automatic-temporary-lifetime-extension"></a>Extending automatic temporary lifetime extension</h3> <p>Temporaries which are immediately referenced in construction are now automatically lifetime extended in <code>match</code> and <code>if</code> constructs. This has the same behavior as lifetime extension for temporaries in block constructs.</p> <p>For example:</p> <pre><code class="language-rust">let a = if true { ..; &amp;temp() // used to error, but now gets lifetime extended } else { ..; &amp;temp() // used to error, but now gets lifetime extended }; </code></pre> <p>and</p> <pre><code class="language-rust">let a = match () { _ =&gt; { ..; &amp;temp() // used to error, but now gets lifetime extended } }; </code></pre> <p>are now consistent with prior behavior:</p> <pre><code class="language-rust">let a = { ..; &amp;temp() // lifetime is extended }; </code></pre> <p>This behavior is backwards compatible since these programs used to fail compilation.</p> <h3><a href="#frame-pointers-enabled-in-standard-library-builds" aria-hidden="true" class="anchor" id="frame-pointers-enabled-in-standard-library-builds"></a>Frame pointers enabled in standard library builds</h3> <p>The standard library distributed by the Rust project is now compiled with <code>-Cforce-frame-pointers=yes</code>, enabling downstream users to more easily profile their programs. Note that the standard library also continues to come up with line-level debug info (e.g., DWARF), though that is <a href="https://blog.rust-lang.org/2024/03/21/Rust-1.77.0.html#enable-strip-in-release-profiles-by-default">stripped by default</a> in Cargo's release profiles.</p> <h3><a href="#stabilized-apis" aria-hidden="true" class="anchor" id="stabilized-apis"></a>Stabilized APIs</h3> <ul> <li><a href="https://doc.rust-lang.org/stable/core/primitive.i32.html#method.unchecked_add"><code>{integer}::unchecked_add</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.i32.html#method.unchecked_mul"><code>{integer}::unchecked_mul</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.i32.html#method.unchecked_sub"><code>{integer}::unchecked_sub</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.split_at_unchecked"><code>&lt;[T]&gt;::split_at_unchecked</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.split_at_mut_unchecked"><code>&lt;[T]&gt;::split_at_mut_unchecked</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.slice.html#method.utf8_chunks"><code>&lt;[u8]&gt;::utf8_chunks</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/str/struct.Utf8Chunks.html"><code>str::Utf8Chunks</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/str/struct.Utf8Chunk.html"><code>str::Utf8Chunk</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.is_aligned"><code>&lt;*const T&gt;::is_aligned</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.is_aligned-1"><code>&lt;*mut T&gt;::is_aligned</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/ptr/struct.NonNull.html#method.is_aligned"><code>NonNull::is_aligned</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.len"><code>&lt;*const [T]&gt;::len</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.len-1"><code>&lt;*mut [T]&gt;::len</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.is_empty"><code>&lt;*const [T]&gt;::is_empty</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.is_empty-1"><code>&lt;*mut [T]&gt;::is_empty</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/ptr/struct.NonNull.html#method.is_empty"><code>NonNull::&lt;[T]&gt;::is_empty</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/ffi/c_str/struct.CStr.html#method.count_bytes"><code>CStr::count_bytes</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/struct.Error.html#method.downcast"><code>io::Error::downcast</code></a></li> <li><a href="https://doc.rust-lang.org/stable/core/num/struct.NonZero.html"><code>num::NonZero&lt;T&gt;</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/path/fn.absolute.html"><code>path::absolute</code></a></li> <li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Literal.html#method.byte_character"><code>proc_macro::Literal::byte_character</code></a></li> <li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Literal.html#method.c_string"><code>proc_macro::Literal::c_string</code></a></li> </ul> <p>These APIs are now stable in const contexts:</p> <ul> <li><a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.into_inner"><code>Atomic*::into_inner</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/struct.Cursor.html#method.new"><code>io::Cursor::new</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/struct.Cursor.html#method.get_ref"><code>io::Cursor::get_ref</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/struct.Cursor.html#method.position"><code>io::Cursor::position</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/fn.empty.html"><code>io::empty</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/fn.repeat.html"><code>io::repeat</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/fn.sink.html"><code>io::sink</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/panic/struct.Location.html#method.caller"><code>panic::Location::caller</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/panic/struct.Location.html#method.file"><code>panic::Location::file</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/panic/struct.Location.html#method.line"><code>panic::Location::line</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/panic/struct.Location.html#method.column"><code>panic::Location::column</code></a></li> </ul> <h3><a href="#other-changes" aria-hidden="true" class="anchor" id="other-changes"></a>Other changes</h3> <p>Check out everything that changed in <a href="https://github.com/rust-lang/rust/releases/tag/1.79.0">Rust</a>, <a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-179-2024-06-13">Cargo</a>, and <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-179">Clippy</a>.</p> <h2><a href="#contributors-to-1790" aria-hidden="true" class="anchor" id="contributors-to-1790"></a>Contributors to 1.79.0</h2> <p>Many people came together to create Rust 1.79.0. We couldn't have done it without all of you. <a href="https://thanks.rust-lang.org/rust/1.79.0/">Thanks!</a></p> </content>
<author>
<name>The Rust Release Team</name>
</author>
</entry>
<entry>
<title>Faster linking times on nightly on Linux using `rust-lld`</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/05/17/enabling-rust-lld-on-linux.html" type="text/html" title="Faster linking times on nightly on Linux using `rust-lld`"/>
<published>2024-05-17T00:00:00+00:00</published>
<updated>2024-05-17T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/05/17/enabling-rust-lld-on-linux.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/05/17/enabling-rust-lld-on-linux.html"><p>TL;DR: rustc will use <code>rust-lld</code> by default on <code>x86_64-unknown-linux-gnu</code> on nightly to significantly reduce linking times.</p> <h4><a href="#some-context" aria-hidden="true" class="anchor" id="some-context"></a>Some context</h4> <p>Linking time is often a big part of compilation time. When rustc needs to build a binary or a shared library, it will usually call the default linker installed on the system to do that (this can be changed on the command-line or by the target for which the code is compiled).</p> <p>The linkers do an important job, with concerns about stability, backwards-compatibility and so on. For these and other reasons, on the most popular operating systems they usually are older programs, designed when computers only had a single core. So, they usually tend to be slow on a modern machine. For example, when building ripgrep 13 in debug mode on Linux, roughly half of the time is actually spent in the linker.</p> <p>There are different linkers, however, and the usual advice to improve linking times is to use one of these newer and faster linkers, like LLVM's <a href="https://lld.llvm.org/"><code>lld</code></a> or Rui Ueyama's <a href="https://github.com/rui314/mold"><code>mold</code></a>.</p> <p>Some of Rust's wasm and aarch64 targets already use <code>lld</code> by default. When using rustup, rustc ships with a version of <code>lld</code> for this purpose. When CI builds LLVM to use in the compiler, it also builds the linker and packages it. It's referred to as <code>rust-lld</code> to avoid colliding with any <code>lld</code> already installed on the user's machine.</p> <p>Since improvements to linking times are substantial, it would be a good default to use in the most popular targets. This has been discussed for a long time, for example in issues <a href="https://github.com/rust-lang/rust/issues/39915">#39915</a> and <a href="https://github.com/rust-lang/rust/issues/71515">#71515</a>, and rustc already offers nightly flags to use <code>rust-lld</code>.</p> <p>By now, we believe we've done all the internal testing that we could, on CI, crater, and our benchmarking infrastructure. We would now like to expand testing and gather real-world feedback and use-cases. Therefore, we will enable <code>rust-lld</code> to be the linker used by default on <code>x86_64-unknown-linux-gnu</code> for nightly builds.</p> <h4><a href="#benefits" aria-hidden="true" class="anchor" id="benefits"></a>Benefits</h4> <p>While this also enables the compiler to use more linker features in the future, the most immediate benefit is much improved linking times.</p> <p>Here are more details from the ripgrep example mentioned above: linking is reduced 7x, resulting in a 40% reduction in end-to-end compilation times.</p> <p><img src="../../../../images/2024-05-17-enabling-rust-lld-on-linux/ripgrep-comparison.png" alt="Before/after comparison of a ripgrep debug build" /></p> <p>Most binaries should see some improvements here, but it's especially significant with e.g. bigger binaries, or when involving debuginfo. These usually see bottlenecks in the linker.</p> <p>Here's <a href="https://perf.rust-lang.org/compare.html?start=b3e117044c7f707293edc040edb93e7ec5f7040a&amp;end=baed03c51a68376c1789cc373581eea0daf89967&amp;stat=instructions%3Au&amp;tab=compile">a link</a> to the complete results from our benchmarks.</p> <p>If testing goes well, we can then stabilize using this faster linker by default for <code>x86_64-unknown-linux-gnu</code> users, before maybe looking at other targets.</p> <h4><a href="#possible-drawbacks" aria-hidden="true" class="anchor" id="possible-drawbacks"></a>Possible drawbacks</h4> <p>From our prior testing, we don't really expect issues to happen in practice. It is a drop-in replacement for the vast majority of cases, but <code>lld</code> is not <em>bug-for-bug</em> compatible with GNU ld.</p> <p>In any case, using <code>rust-lld</code> can be disabled if any problem occurs: use the <code>-Z linker-features=-lld</code> flag to revert to using the system's default linker.</p> <p>Some crates somehow relying on these differences could need additional link args. For example, we saw &lt;20 crates in the crater run failing to link because of a different default about <a href="https://lld.llvm.org/ELF/start-stop-gc">encapsulation symbols</a>: these could require <code>-Clink-arg=-Wl,-z,nostart-stop-gc</code> to match the legacy GNU ld behavior.</p> <p>Some of the big gains in performance come from parallelism, which could be undesirable in resource-constrained environments.</p> <h4><a href="#summary" aria-hidden="true" class="anchor" id="summary"></a>Summary</h4> <p>rustc will use <code>rust-lld</code> on <code>x86_64-unknown-linux-gnu</code> nightlies, for much improved linking times, starting in tomorrow's rustup nightly (<code>nightly-2024-05-18</code>). Let us know if you encounter problems, by <a href="https://github.com/rust-lang/rust/issues/new/choose">opening an issue</a> on GitHub.</p> <p>If that happens, you can revert to the default linker with the <code>-Z linker-features=-lld</code> flag. Either by adding it to the usual <code>RUSTFLAGS</code> environment variable, or to a project's <a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>.cargo/config.toml</code></a> configuration file, like so:</p> <pre><code class="language-toml">[target.x86_64-unknown-linux-gnu] rustflags = [&quot;-Zlinker-features=-lld&quot;] </code></pre> </content>
<author>
<name>Rémy Rakic</name>
</author>
</entry>
<entry>
<title>Rust participates in OSPP 2024</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/05/07/OSPP-2024.html" type="text/html" title="Rust participates in OSPP 2024"/>
<published>2024-05-07T00:00:00+00:00</published>
<updated>2024-05-07T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/05/07/OSPP-2024.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/05/07/OSPP-2024.html"><p>Similar to our <a href="https://blog.rust-lang.org/2024/02/21/Rust-participates-in-GSoC-2024.html">previous</a> <a href="https://blog.rust-lang.org/2024/05/01/gsoc-2024-selected-projects.html">announcements</a> of the Rust Project's participation in Google Summer of Code (GSoC), we are now announcing our participation in <a href="https://summer-ospp.ac.cn/">Open Source Promotion Plan (OSPP) 2024</a>.</p> <p>OSPP is a program organized in large part by The Institute of Software Chinese Academy of Sciences. Its goal is to encourage college students to participate in developing and maintaining open source software. The Rust Project is <a href="https://summer-ospp.ac.cn/org/orgdetail/11769be7-d00a-4931-be95-13595ac181e4?lang=en">already registered</a> and has a number of projects available for mentorship:</p> <ul> <li><a href="https://summer-ospp.ac.cn/org/prodetail/241170274">C codegen backend for rustc</a></li> <li><a href="https://summer-ospp.ac.cn/org/prodetail/241170275">Extend annotate-snippets with features required by rustc</a></li> <li><a href="https://summer-ospp.ac.cn/org/prodetail/241170277">Improve bootstrap</a></li> <li><a href="https://summer-ospp.ac.cn/org/prodetail/241170528">Modernize the libc crate</a></li> <li><a href="https://summer-ospp.ac.cn/org/prodetail/241170529">Improve infrastructure automation tools</a></li> </ul> <p>Eligibility is limited to students and there is a <a href="https://summer-ospp.ac.cn/help/en/student/">guide</a> for potential participants. Student registration ends on the 3rd of June with the project application deadline a day later.</p> <p>Unlike GSoC which allows students to propose their own projects, OSPP requires that students only apply for one of the registered projects. We do have an <a href="https://rust-lang.zulipchat.com/#narrow/stream/436418-ospp">#ospp</a> Zulip stream and potential contributors are encouraged to join and discuss details about the projects and connect with mentors.</p> <p>After the project application window closes on June 4th, we will review and select participants, which will be announced on June 26th. From there, students will participate through to the end of September.</p> <p>As with GSoC, this is our first year participating in this program. We are incredibly excited for this opportunity to further expand into new open source communities and we're hopeful for a productive and educational summer.</p> </content>
<author>
<name>Amanieu d'Antras, Jack Huey, and Jakub Beránek</name>
</author>
</entry>
<entry>
<title>Automatic checking of cfgs at compile-time</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/05/06/check-cfg.html" type="text/html" title="Automatic checking of cfgs at compile-time"/>
<published>2024-05-06T00:00:00+00:00</published>
<updated>2024-05-06T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/05/06/check-cfg.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/05/06/check-cfg.html"><p>The Cargo and Compiler team are delighted to announce that starting with Rust 1.80 (or nightly-2024-05-05) every <em>reachable</em> <code>#[cfg]</code> will be <strong>automatically checked</strong> that they match the <strong>expected config names and values</strong>.</p> <p>This can help with verifying that the crate is correctly handling conditional compilation for different target platforms or features. It ensures that the cfg settings are consistent between what is intended and what is used, helping to catch potential bugs or errors early in the development process.</p> <p>This addresses a common pitfall for new and advanced users.</p> <p>This is another step to our commitment to provide user-focused tooling and we are eager and excited to finally see it fixed, after more than two years since the original <a href="https://github.com/rust-lang/rfcs/pull/3013">RFC 3013</a><sup class="footnote-ref"><a href="#fn-1" id="fnref-1" data-footnote-ref>1</a></sup>.</p> <h2><a href="#a-look-at-the-feature" aria-hidden="true" class="anchor" id="a-look-at-the-feature"></a>A look at the feature</h2> <p>Every time a Cargo feature is declared that feature is transformed into a config that is passed to <code>rustc</code> (the Rust compiler) so it can verify with it along with <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html#well-known-names-and-values">well known cfgs</a> if any of the <code>#[cfg]</code>, <code>#![cfg_attr]</code> and <code>cfg!</code> have unexpected configs and report a warning with the <code>unexpected_cfgs</code> lint.</p> <p><em><code>Cargo.toml</code></em>:</p> <pre><code class="language-toml">[package] name = &quot;foo&quot; [features] lasers = [] zapping = [] </code></pre> <p><em><code>src/lib.rs</code>:</em></p> <pre><code class="language-rust">#[cfg(feature = &quot;lasers&quot;)] // This condition is expected // as &quot;lasers&quot; is an expected value // of the `feature` cfg fn shoot_lasers() {} #[cfg(feature = &quot;monkeys&quot;)] // This condition is UNEXPECTED // as &quot;monkeys&quot; is NOT an expected // value of the `feature` cfg fn write_shakespeare() {} #[cfg(windosw)] // This condition is UNEXPECTED // it's supposed to be `windows` fn win() {} </code></pre> <p><em><code>cargo check</code></em>:</p> <p><img src="../../../../images/2024-05-06-check-cfg/cargo-check.svg" alt="cargo-check" /></p> <h2><a href="#expecting-custom-cfgs" aria-hidden="true" class="anchor" id="expecting-custom-cfgs"></a>Expecting custom cfgs</h2> <p><em>UPDATE: This section was added with the release of nightly-2024-05-19.</em></p> <blockquote> <p>In Cargo point-of-view: a custom cfg is one that is neither defined by <code>rustc</code> nor by a Cargo feature. Think of <code>tokio_unstable</code>, <code>has_foo</code>, ... but not <code>feature = &quot;lasers&quot;</code>, <code>unix</code> or <code>debug_assertions</code></p> </blockquote> <p>Some crates might use custom cfgs, like <code>loom</code>, <code>fuzzing</code> or <code>tokio_unstable</code> that they expected from the environment (<code>RUSTFLAGS</code> or other means) and which are always statically known at compile time. For those cases, Cargo provides via the <code>[lints]</code> table a way to statically declare those cfgs as expected.</p> <p>Defining those custom cfgs as expected is done through the special <code>check-cfg</code> config under <code>[lints.rust.unexpected_cfgs]</code>:</p> <p><em><code>Cargo.toml</code></em></p> <pre><code class="language-toml">[lints.rust] unexpected_cfgs = { level = &quot;warn&quot;, check-cfg = ['cfg(loom)', 'cfg(fuzzing)'] } </code></pre> <h2><a href="#custom-cfgs-in-build-scripts" aria-hidden="true" class="anchor" id="custom-cfgs-in-build-scripts"></a>Custom cfgs in build scripts</h2> <p>On the other hand some crates use custom cfgs that are enabled by some logic in the crate <code>build.rs</code>. For those crates Cargo provides a new instruction: <a href="https://doc.rust-lang.org/nightly/cargo/reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg</code></a><sup class="footnote-ref"><a href="#fn-2" id="fnref-2" data-footnote-ref>2</a></sup> (or <code>cargo:rustc-check-cfg</code> for older Cargo version).</p> <p>The syntax to use is described in the <a href="https://doc.rust-lang.org/nightly/rustc/">rustc book</a> section <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html">checking configuration</a>, but in a nutshell the basic syntax of <code>--check-cfg</code> is:</p> <pre><code>cfg(name, values(&quot;value1&quot;, &quot;value2&quot;, ..., &quot;valueN&quot;)) </code></pre> <p>Note that every custom cfgs must always be expected, regardless if the cfg is active or not!</p> <h3><a href="#buildrs-example" aria-hidden="true" class="anchor" id="buildrs-example"></a><code>build.rs</code> example</h3> <p><code>build.rs</code>:</p> <pre><code class="language-rust">fn main() { println!(&quot;cargo::rustc-check-cfg=cfg(has_foo)&quot;); // ^^^^^^^^^^^^^^^^^^^^^^ new with Cargo 1.80 if has_foo() { println!(&quot;cargo::rustc-cfg=has_foo&quot;); } } </code></pre> <blockquote> <p>Each <code>cargo::rustc-cfg</code> should have an accompanying <strong>unconditional</strong> <code>cargo::rustc-check-cfg</code> directive to avoid warnings like this: <code>unexpected cfg condition name: has_foo</code>.</p> </blockquote> <h3><a href="#equivalence-table" aria-hidden="true" class="anchor" id="equivalence-table"></a>Equivalence table</h3> <table> <thead> <tr> <th><code>cargo::rustc-cfg</code></th> <th><code>cargo::rustc-check-cfg</code></th> </tr> </thead> <tbody> <tr> <td><code>foo</code></td> <td><code>cfg(foo)</code> or <code>cfg(foo, values(none()))</code></td> </tr> <tr> <td><code>foo=&quot;&quot;</code></td> <td><code>cfg(foo, values(&quot;&quot;))</code></td> </tr> <tr> <td><code>foo=&quot;bar&quot;</code></td> <td><code>cfg(foo, values(&quot;bar&quot;))</code></td> </tr> <tr> <td><code>foo=&quot;1&quot;</code> and <code>foo=&quot;2&quot;</code></td> <td><code>cfg(foo, values(&quot;1&quot;, &quot;2&quot;))</code></td> </tr> <tr> <td><code>foo=&quot;1&quot;</code> and <code>bar=&quot;2&quot;</code></td> <td><code>cfg(foo, values(&quot;1&quot;))</code> and <code>cfg(bar, values(&quot;2&quot;))</code></td> </tr> <tr> <td><code>foo</code> and <code>foo=&quot;bar&quot;</code></td> <td><code>cfg(foo, values(none(), &quot;bar&quot;))</code></td> </tr> </tbody> </table> <p>More details can be found in the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html"><code>rustc</code> book</a>.</p> <h2><a href="#frequently-asked-questions" aria-hidden="true" class="anchor" id="frequently-asked-questions"></a>Frequently asked questions</h2> <h3><a href="#can-it-be-disabled" aria-hidden="true" class="anchor" id="can-it-be-disabled"></a>Can it be disabled?</h3> <p>For Cargo users, the feature is <strong>always on</strong> and <em>cannot</em> be disabled, but like any other lints it can be controlled: <code>#![warn(unexpected_cfgs)]</code>.</p> <h3><a href="#does-the-lint-affect-dependencies" aria-hidden="true" class="anchor" id="does-the-lint-affect-dependencies"></a>Does the lint affect dependencies?</h3> <p>No, like most lints, <code>unexpected_cfgs</code> will only be reported for local packages thanks to <a href="https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints">cap-lints</a>.</p> <h3><a href="#how-does-it-interact-with-the-rustflags-env" aria-hidden="true" class="anchor" id="how-does-it-interact-with-the-rustflags-env"></a>How does it interact with the <code>RUSTFLAGS</code> env?</h3> <p>You should be able to use the <code>RUSTFLAGS</code> environment variable like it was before. <em>Currently <code>--cfg</code> arguments are not checked, only usage in code are.</em></p> <p>This means that doing <code>RUSTFLAGS=&quot;--cfg tokio_unstable&quot; cargo check</code> will not report any warnings, unless <code>tokio_unstable</code> is used within your local crates, in which case crate author will need to make sure that that custom cfg is expected with <code>cargo::rustc-check-cfg</code> in the <code>build.rs</code> of that crate.</p> <h3><a href="#how-to-expect-custom-cfgs-without-a-buildrs" aria-hidden="true" class="anchor" id="how-to-expect-custom-cfgs-without-a-buildrs"></a>How to expect custom cfgs without a <code>build.rs</code>?</h3> <p><em>UPDATE: Cargo with nightly-2024-05-19 now provides the <code>[lints.rust.unexpected_cfgs.check-cfg]</code> config to address the statically known custom cfgs.</em></p> <p><del>There is <strong>currently no way</strong> to expect a custom cfg other than with <code>cargo::rustc-check-cfg</code> in a <code>build.rs</code>.</del></p> <p>Crate authors that don't want to use a <code>build.rs</code> and cannot use <code>[lints.rust.unexpected_cfgs.check-cfg]</code>, are encouraged to use Cargo features instead.</p> <h3><a href="#how-does-it-interact-with-other-build-systems" aria-hidden="true" class="anchor" id="how-does-it-interact-with-other-build-systems"></a>How does it interact with other build systems?</h3> <p>Non-Cargo based build systems are not affected by the lint by default. Build system authors that wish to have the same functionality should look at the <code>rustc</code> documentation for the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html"><code>--check-cfg</code></a> flag for a detailed explanation of how to achieve the same functionality.</p> <section class="footnotes" data-footnotes> <ol> <li id="fn-1"> <p>The stabilized implementation and RFC 3013 diverge significantly, in particular there is only one form for <code>--check-cfg</code>: <code>cfg()</code> (instead of <code>values()</code> and <code>names()</code> being incomplete and subtlety incompatible with each other). <a href="#fnref-1" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="1" aria-label="Back to reference 1">↩</a></p> </li> <li id="fn-2"> <p><code>cargo::rustc-check-cfg</code> will start working in Rust 1.80 (or nightly-2024-05-05). From Rust 1.77 to Rust 1.79 <em>(inclusive)</em> it is silently ignored. In Rust 1.76 and below a warning is emitted when used without the unstable Cargo flag <code>-Zcheck-cfg</code>. <a href="#fnref-2" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="2" aria-label="Back to reference 2">↩</a></p> </li> </ol> </section> </content>
<author>
<name>Urgau</name>
</author>
</entry>
<entry>
<title>Announcing Rustup 1.27.1</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/05/06/Rustup-1.27.1.html" type="text/html" title="Announcing Rustup 1.27.1"/>
<published>2024-05-06T00:00:00+00:00</published>
<updated>2024-05-06T00:00:01+00:00</updated>
<id>https://blog.rust-lang.org/2024/05/06/Rustup-1.27.1.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/05/06/Rustup-1.27.1.html"><p>The Rustup team is happy to announce the release of Rustup version 1.27.1. <a href="https://rustup.rs">Rustup</a> is the recommended tool to install <a href="https://www.rust-lang.org">Rust</a>, a programming language that is empowering everyone to build reliable and efficient software.</p> <p>If you have a previous version of Rustup installed, getting Rustup 1.27.1 is as easy as stopping any programs which may be using Rustup (e.g. closing your IDE) and running:</p> <pre><code class="language-console">$ rustup self update </code></pre> <p>Rustup will also automatically update itself at the end of a normal toolchain update:</p> <pre><code class="language-console">$ rustup update </code></pre> <p>If you don't have it already, you can <a href="https://rustup.rs">get Rustup</a> from the appropriate page on our website.</p> <h2><a href="#whats-new-in-rustup-1271" aria-hidden="true" class="anchor" id="whats-new-in-rustup-1271"></a>What's new in Rustup 1.27.1</h2> <p>This new Rustup release involves some minor bug fixes.</p> <p>The headlines for this release are:</p> <ol> <li>Prebuilt Rustup binaries should be working on older macOS versions again.</li> <li><code>rustup-init</code> will no longer fail when <code>fish</code> is installed but <code>~/.config/fish/conf.d</code> hasn't been created.</li> <li>Regressions regarding symlinked <code>RUSTUP_HOME/(toolchains|downloads|tmp)</code> have been addressed.</li> </ol> <p>Full details are available in the <a href="https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md">changelog</a>!</p> <p>Rustup's documentation is also available in <a href="https://rust-lang.github.io/rustup/">the Rustup Book</a>.</p> <h2><a href="#thanks" aria-hidden="true" class="anchor" id="thanks"></a>Thanks</h2> <p>Thanks again to all the contributors who made Rustup 1.27.1 possible!</p> <ul> <li>Anas (0x61nas)</li> <li>cuiyourong (cuiyourong)</li> <li>Dirkjan Ochtman (djc)</li> <li>Eric Huss (ehuss)</li> <li>eth3lbert (eth3lbert)</li> <li>hev (heiher)</li> <li>klensy (klensy)</li> <li>Chih Wang (ongchi)</li> <li>Adam (pie-flavor)</li> <li>rami3l (rami3l)</li> <li>Robert (rben01)</li> <li>Robert Collins (rbtcollins)</li> <li>Sun Bin (shandongbinzhou)</li> <li>Samuel Moelius (smoelius)</li> <li>vpochapuis (vpochapuis)</li> <li>Renovate Bot (renovate)</li> </ul> </content>
<author>
<name>The Rustup Team</name>
</author>
</entry>
<entry>
<title>Announcing Rust 1.78.0</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html" type="text/html" title="Announcing Rust 1.78.0"/>
<published>2024-05-02T00:00:00+00:00</published>
<updated>2024-05-02T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html"><p>The Rust team is happy to announce a new version of Rust, 1.78.0. Rust is a programming language empowering everyone to build reliable and efficient software.</p> <p>If you have a previous version of Rust installed via <code>rustup</code>, you can get 1.78.0 with:</p> <pre><code class="language-console">$ rustup update stable </code></pre> <p>If you don't have it already, you can <a href="https://www.rust-lang.org/install.html">get <code>rustup</code></a> from the appropriate page on our website, and check out the <a href="https://doc.rust-lang.org/nightly/releases.html#version-1780-2024-05-02">detailed release notes for 1.78.0</a>.</p> <p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel (<code>rustup default beta</code>) or the nightly channel (<code>rustup default nightly</code>). Please <a href="https://github.com/rust-lang/rust/issues/new/choose">report</a> any bugs you might come across!</p> <h2><a href="#whats-in-1780-stable" aria-hidden="true" class="anchor" id="whats-in-1780-stable"></a>What's in 1.78.0 stable</h2> <h3><a href="#diagnostic-attributes" aria-hidden="true" class="anchor" id="diagnostic-attributes"></a>Diagnostic attributes</h3> <p>Rust now supports a <code>#[diagnostic]</code> attribute namespace to influence compiler error messages. These are treated as hints which the compiler is not <em>required</em> to use, and it is also not an error to provide a diagnostic that the compiler doesn't recognize. This flexibility allows source code to provide diagnostics even when they're not supported by all compilers, whether those are different versions or entirely different implementations.</p> <p>With this namespace comes the first supported attribute, <code>#[diagnostic::on_unimplemented]</code>, which can be placed on a trait to customize the message when that trait is required but hasn't been implemented on a type. Consider the example given in the <a href="https://github.com/rust-lang/rust/pull/119888/">stabilization pull request</a>:</p> <pre><code class="language-rust">#[diagnostic::on_unimplemented( message = &quot;My Message for `ImportantTrait&lt;{A}&gt;` is not implemented for `{Self}`&quot;, label = &quot;My Label&quot;, note = &quot;Note 1&quot;, note = &quot;Note 2&quot; )] trait ImportantTrait&lt;A&gt; {} fn use_my_trait(_: impl ImportantTrait&lt;i32&gt;) {} fn main() { use_my_trait(String::new()); } </code></pre> <p>Previously, the compiler would give a builtin error like this:</p> <pre><code>error[E0277]: the trait bound `String: ImportantTrait&lt;i32&gt;` is not satisfied --&gt; src/main.rs:12:18 | 12 | use_my_trait(String::new()); | ------------ ^^^^^^^^^^^^^ the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String` | | | required by a bound introduced by this call | </code></pre> <p>With <code>#[diagnostic::on_unimplemented]</code>, its custom message fills the primary error line, and its custom label is placed on the source output. The original label is still written as help output, and any custom notes are written as well. (These exact details are subject to change.)</p> <pre><code>error[E0277]: My Message for `ImportantTrait&lt;i32&gt;` is not implemented for `String` --&gt; src/main.rs:12:18 | 12 | use_my_trait(String::new()); | ------------ ^^^^^^^^^^^^^ My Label | | | required by a bound introduced by this call | = help: the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String` = note: Note 1 = note: Note 2 </code></pre> <p>For trait authors, this kind of diagnostic is more useful if you can provide a better hint than just talking about the missing implementation itself. For example, this is an abridged sample from the standard library:</p> <pre><code class="language-rust">#[diagnostic::on_unimplemented( message = &quot;the size for values of type `{Self}` cannot be known at compilation time&quot;, label = &quot;doesn't have a size known at compile-time&quot; )] pub trait Sized {} </code></pre> <p>For more information, see the reference section on <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">the <code>diagnostic</code> tool attribute namespace</a>.</p> <h3><a href="#asserting-unsafe-preconditions" aria-hidden="true" class="anchor" id="asserting-unsafe-preconditions"></a>Asserting <code>unsafe</code> preconditions</h3> <p>The Rust standard library has a number of assertions for the preconditions of <code>unsafe</code> functions, but historically they have only been enabled in <code>#[cfg(debug_assertions)]</code> builds of the standard library to avoid affecting release performance. However, since the standard library is usually compiled and distributed in release mode, most Rust developers weren't ever executing these checks at all.</p> <p>Now, the condition for these assertions is delayed until code generation, so they will be checked depending on the user's own setting for debug assertions -- enabled by default in debug and test builds. This change helps users catch undefined behavior in their code, though the details of how much is checked are generally not stable.</p> <p>For example, <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>slice::from_raw_parts</code></a> requires an aligned non-null pointer. The following use of a purposely-misaligned pointer has undefined behavior, and while if you were unlucky it may have <em>appeared</em> to &quot;work&quot; in the past, the debug assertion can now catch it:</p> <pre><code class="language-rust">fn main() { let slice: &amp;[u8] = &amp;[1, 2, 3, 4, 5]; let ptr = slice.as_ptr(); // Create an offset from `ptr` that will always be one off from `u16`'s correct alignment let i = usize::from(ptr as usize &amp; 1 == 0); let slice16: &amp;[u16] = unsafe { std::slice::from_raw_parts(ptr.add(i).cast::&lt;u16&gt;(), 2) }; dbg!(slice16); } </code></pre> <pre><code>thread 'main' panicked at library/core/src/panicking.rs:220:5: unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX` note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace thread caused non-unwinding panic. aborting. </code></pre> <h3><a href="#deterministic-realignment" aria-hidden="true" class="anchor" id="deterministic-realignment"></a>Deterministic realignment</h3> <p>The standard library has a few functions that change the alignment of pointers and slices, but they previously had caveats that made them difficult to rely on in practice, if you followed their documentation precisely. Those caveats primarily existed as a hedge against <code>const</code> evaluation, but they're only stable for non-<code>const</code> use anyway. They are now promised to have consistent runtime behavior according to their actual inputs.</p> <ul> <li> <p><a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset"><code>pointer::align_offset</code></a> computes the offset needed to change a pointer to the given alignment. It returns <code>usize::MAX</code> if that is not possible, but it was previously permitted to <em>always</em> return <code>usize::MAX</code>, and now that behavior is removed.</p> </li> <li> <p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a> and <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a> both transmute slices to an aligned middle slice and the remaining unaligned head and tail slices. These methods now promise to return the largest possible middle part, rather than allowing the implementation to return something less optimal like returning everything as the head slice.</p> </li> </ul> <h3><a href="#stabilized-apis" aria-hidden="true" class="anchor" id="stabilized-apis"></a>Stabilized APIs</h3> <ul> <li><a href="https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#impl-Read-for-%26Stdin"><code>impl Read for &amp;Stdin</code></a></li> <li><a href="https://github.com/rust-lang/rust/pull/113833/">Accept non <code>'static</code> lifetimes for several <code>std::error::Error</code> related implementations</a></li> <li><a href="https://github.com/rust-lang/rust/pull/114655/">Make <code>impl&lt;Fd: AsFd&gt;</code> impl take <code>?Sized</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/io/struct.Error.html#impl-From%3CTryReserveError%3E-for-Error"><code>impl From&lt;TryReserveError&gt; for io::Error</code></a></li> </ul> <p>These APIs are now stable in const contexts:</p> <ul> <li><a href="https://doc.rust-lang.org/stable/std/sync/struct.Barrier.html#method.new"><code>Barrier::new()</code></a></li> </ul> <h3><a href="#compatibility-notes" aria-hidden="true" class="anchor" id="compatibility-notes"></a>Compatibility notes</h3> <ul> <li>As <a href="https://blog.rust-lang.org/2024/02/26/Windows-7.html">previously announced</a>, Rust 1.78 has increased its minimum requirement to Windows 10 for the following targets: <ul> <li><code>x86_64-pc-windows-msvc</code></li> <li><code>i686-pc-windows-msvc</code></li> <li><code>x86_64-pc-windows-gnu</code></li> <li><code>i686-pc-windows-gnu</code></li> <li><code>x86_64-pc-windows-gnullvm</code></li> <li><code>i686-pc-windows-gnullvm</code></li> </ul> </li> <li>Rust 1.78 has upgraded its bundled LLVM to version 18, completing the announced <a href="https://blog.rust-lang.org/2024/03/30/i128-layout-update.html"><code>u128</code>/<code>i128</code> ABI change</a> for x86-32 and x86-64 targets. Distributors that use their own LLVM older than 18 may still face the calling convention bugs mentioned in that post.</li> </ul> <h3><a href="#other-changes" aria-hidden="true" class="anchor" id="other-changes"></a>Other changes</h3> <p>Check out everything that changed in <a href="https://github.com/rust-lang/rust/releases/tag/1.78.0">Rust</a>, <a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-178-2024-05-02">Cargo</a>, and <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-178">Clippy</a>.</p> <h2><a href="#contributors-to-1780" aria-hidden="true" class="anchor" id="contributors-to-1780"></a>Contributors to 1.78.0</h2> <p>Many people came together to create Rust 1.78.0. We couldn't have done it without all of you. <a href="https://thanks.rust-lang.org/rust/1.78.0/">Thanks!</a></p> </content>
<author>
<name>The Rust Release Team</name>
</author>
</entry>
<entry>
<title>Announcing Google Summer of Code 2024 selected projects</title>
<link rel="alternate" href="https://blog.rust-lang.org/2024/05/01/gsoc-2024-selected-projects.html" type="text/html" title="Announcing Google Summer of Code 2024 selected projects"/>
<published>2024-05-01T00:00:00+00:00</published>
<updated>2024-05-01T00:00:00+00:00</updated>
<id>https://blog.rust-lang.org/2024/05/01/gsoc-2024-selected-projects.html</id>
<content type="html" xml:base="https://blog.rust-lang.org/2024/05/01/gsoc-2024-selected-projects.html"><p>The Rust Project is <a href="https://blog.rust-lang.org/2024/02/21/Rust-participates-in-GSoC-2024.html">participating</a> in <a href="https://summerofcode.withgoogle.com">Google Summer of Code (GSoC) 2024</a>, a global program organized by Google which is designed to bring new contributors to the world of open-source.</p> <p>In February, we published a list of <a href="https://github.com/rust-lang/google-summer-of-code">GSoC project ideas</a>, and started discussing these projects with potential GSoC applicants on our <a href="https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc">Zulip</a>. We were pleasantly surprised by the amount of people that wanted to participate in these projects and that led to many fruitful discussions with members of various Rust teams. Some of them even immediately began contributing to various repositories of the Rust Project, even before GSoC officially started!</p> <p>After the initial discussions, GSoC applicants prepared and submitted their project proposals. We received 65 (!) proposals in total. We are happy to see that there was so much interest, given that this is the first time the Rust Project is participating in GSoC.</p> <p>A team of mentors primarily composed of Rust Project contributors then thoroughly examined the submitted proposals. GSoC required us to produce a ranked list of the best proposals, which was a challenging task in itself since Rust is a big project with many priorities! We went through many rounds of discussions and had to consider many factors, such as prior conversations with the given applicant, the quality and scope of their proposal, the importance of the proposed project for the Rust Project and its wider community, but also the availability of mentors, who are often volunteers and thus have limited time available for mentoring.</p> <p>In many cases, we had multiple proposals that aimed to accomplish the same goal. Therefore, we had to pick only one per project topic despite receiving several high-quality proposals from people we'd love to work with. We also often had to choose between great proposals targeting different work within the same Rust component to avoid overloading a single mentor with multiple projects.</p> <p>In the end, we narrowed the list down to twelve best proposals, which we felt was the maximum amount that we could realistically support with our available mentor pool. We submitted this list and eagerly awaited how many of these twelve proposals would be accepted into GSoC.</p> <h2><a href="#selected-projects" aria-hidden="true" class="anchor" id="selected-projects"></a>Selected projects</h2> <p>On the 1st of May, Google has announced the accepted projects. We are happy to announce that <code>9</code> proposals out of the twelve that we have submitted were accepted by Google, and will thus participate in Google Summer of Code 2024! Below you can find the list of accepted proposals (in alphabetical order), along with the names of their authors and the assigned mentor(s):</p> <ul> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/hADSyIDV">Adding lint-level configuration to cargo-semver-checks</a></strong> by Max Carr, mentored by Predrag Gruevski</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/zxxeGZMt">Implementation of a Faster Register Allocator For Cranelift</a></strong> by d-sonuga, mentored by Chris Fallin and Amanieu d'Antras</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/MeyNanKI">Improve Rust benchmark suite</a></strong> by s7tya, mentored by Jakub Beránek</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/jjnidpgn">Move cargo shell completions to Rust</a></strong> by shanmu, mentored by Ed Page</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/P5BC91Hr">Rewriting Esoteric, Error-Prone Makefile Tests Using Robust Rust Features</a></strong> by Julien Robert, mentored by Jieyou Xu</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/gHEu3vxc">Rewriting the Rewrite trait</a></strong> by SeoYoung Lee, mentored by Yacin Tmimi</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/IIHP5ozV">Rust to .NET compiler - add support for compiling &amp; running cargo tests</a></strong> by Fractal Fir, mentored by Jack Huey</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/kXG0mZoj">Sandboxed and Deterministic Proc Macro using Wasm</a></strong> by Apurva Mishra, mentored by David Lattimore</li> <li><strong><a href="https://summerofcode.withgoogle.com/programs/2024/projects/rk1Ey4hN">Tokio async support in Miri</a></strong> by Tiffany Pek Yuan, mentored by Oli Scherer</li> </ul> <p><strong>Congratulations to all applicants whose project was selected!</strong> The mentors are looking forward to working with you on these exciting projects to improve the Rust ecosystem. You can expect to hear from us soon, so that we can start coordinating the work on your GSoC projects.</p> <p>We would also like to thank all the applicants whose proposal was sadly not accepted, for their interactions with the Rust community and contributions to various Rust projects. There were some great proposals that did not make the cut, in large part because of limited review capacity. However, even if your proposal was not accepted, we would be happy if you would consider contributing to the projects that got you interested, even outside GSoC! Our <a href="https://github.com/rust-lang/google-summer-of-code">project idea list</a> is still actual, and could serve as a general entry point for contributors that would like to work on projects that would help the Rust Project maintainers and the Rust ecosystem.</p> <p>Assuming our involvement in GSoC 2024 is successful, there's a good chance we'll participate next year as well (though we can't promise anything yet) and we hope to receive your proposals again in the future! We also are planning to participate in similar programs in the very near future. Those announcements will come in separate blog posts, so make sure to subscribe to this blog so that you don't miss anything.</p> <p>The accepted GSoC projects will run for several months. After GSoC 2024 finishes (in autumn of 2024), we plan to publish a blog post in which we will summarize the outcome of the accepted projects.</p> </content>
<author>
<name>Jakub Beránek, Jack Huey and Paul Lenz</name>
</author>
</entry>
</feed>